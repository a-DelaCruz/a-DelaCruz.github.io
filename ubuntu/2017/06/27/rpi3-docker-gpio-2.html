<!DOCTYPE html>
<html lang="en-US">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>RPi 3: GPIO on .Net Core consoleApp inside Docker using bcm2835 library: #2</title>

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href=" /assets/img/AJ.png ">
    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({google_ad_client: "ca-pub-6013311002995151", enable_page_level_ads: true});
    </script>

    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>RPi 3: GPIO on .Net Core consoleApp inside Docker using bcm2835 library: #2 | My Personal Notes</title>
<meta property="og:title" content="RPi 3: GPIO on .Net Core consoleApp inside Docker using bcm2835 library: #2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="GPIO Now let’s try our RPi3 GPIO. In our testapp project we created earlier…we’ll have a directory tree like mine: /bin /obj testapp.csproj Program.cs Then modify Program.cs with these codes. What it does is we use libbcm2835.so C internal commands into our C# app using PInvoke. Take note of the PIN Numbering: bcm2835 library use physical numbering so RPI_GPIO_P1_07 is equal to GPIO4 of our RPi3. using System; using System.Runtime.InteropServices; namespace testapp { class Program { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte RPI_GPIO_P1_07 = 4; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); if (bcm2835_init() == 1) { bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); // Blink while(true) { // Turn it on bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); // wait bcm2835_delay(500); // turn it off bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); // wait bcm2835_delay(500); } } bcm2835_close(); } } } Then publish and get our new /publish folder contents. And copy it inside our RPi3. testapp&gt; dotnet publish -r ubuntu.16.04-arm //then copy /publish folder into our RPi3 Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3. In RPi3, let us run our updated docker image then test our testapp on it. $ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share Note :--rm means that once we exit docker it will clean our previouly runned docker image. Make sure that you have libbcm2835.so inside the /lib/arm-~ folder or it will complain about running it in SDK. # cd /home/share/publish /home/share/publish# /opt/dotnet/dotnet ./testapp.dll Your led should be blinking right now…. part3" />
<meta property="og:description" content="GPIO Now let’s try our RPi3 GPIO. In our testapp project we created earlier…we’ll have a directory tree like mine: /bin /obj testapp.csproj Program.cs Then modify Program.cs with these codes. What it does is we use libbcm2835.so C internal commands into our C# app using PInvoke. Take note of the PIN Numbering: bcm2835 library use physical numbering so RPI_GPIO_P1_07 is equal to GPIO4 of our RPi3. using System; using System.Runtime.InteropServices; namespace testapp { class Program { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte RPI_GPIO_P1_07 = 4; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); if (bcm2835_init() == 1) { bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); // Blink while(true) { // Turn it on bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); // wait bcm2835_delay(500); // turn it off bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); // wait bcm2835_delay(500); } } bcm2835_close(); } } } Then publish and get our new /publish folder contents. And copy it inside our RPi3. testapp&gt; dotnet publish -r ubuntu.16.04-arm //then copy /publish folder into our RPi3 Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3. In RPi3, let us run our updated docker image then test our testapp on it. $ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share Note :--rm means that once we exit docker it will clean our previouly runned docker image. Make sure that you have libbcm2835.so inside the /lib/arm-~ folder or it will complain about running it in SDK. # cd /home/share/publish /home/share/publish# /opt/dotnet/dotnet ./testapp.dll Your led should be blinking right now…. part3" />
<meta property="og:site_name" content="My Personal Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-27T00:00:00+08:00" />
<script type="application/ld+json">
{"name":null,"description":"GPIO Now let’s try our RPi3 GPIO. In our testapp project we created earlier…we’ll have a directory tree like mine: /bin /obj testapp.csproj Program.cs Then modify Program.cs with these codes. What it does is we use libbcm2835.so C internal commands into our C# app using PInvoke. Take note of the PIN Numbering: bcm2835 library use physical numbering so RPI_GPIO_P1_07 is equal to GPIO4 of our RPi3. using System; using System.Runtime.InteropServices; namespace testapp { class Program { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte RPI_GPIO_P1_07 = 4; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); if (bcm2835_init() == 1) { bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); // Blink while(true) { // Turn it on bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); // wait bcm2835_delay(500); // turn it off bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); // wait bcm2835_delay(500); } } bcm2835_close(); } } } Then publish and get our new /publish folder contents. And copy it inside our RPi3. testapp&gt; dotnet publish -r ubuntu.16.04-arm //then copy /publish folder into our RPi3 Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3. In RPi3, let us run our updated docker image then test our testapp on it. $ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share Note :--rm means that once we exit docker it will clean our previouly runned docker image. Make sure that you have libbcm2835.so inside the /lib/arm-~ folder or it will complain about running it in SDK. # cd /home/share/publish /home/share/publish# /opt/dotnet/dotnet ./testapp.dll Your led should be blinking right now…. part3","author":null,"@type":"BlogPosting","url":"/ubuntu/2017/06/27/rpi3-docker-gpio-2.html","publisher":null,"image":null,"headline":"RPi 3: GPIO on .Net Core consoleApp inside Docker using bcm2835 library: #2","dateModified":"2017-06-27T00:00:00+08:00","datePublished":"2017-06-27T00:00:00+08:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"/ubuntu/2017/06/27/rpi3-docker-gpio-2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

    <body>
        <div class="container-body">
            <div class="header brand">
            <img src="/assets/img/AJ.png" />
</div>

<div class="header ads1">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- Ad 2 Horizontal -->
      <ins class="adsbygoogle"
      style="display:inline-block;width:320px;height:50px"
      data-ad-client="ca-pub-6013311002995151"
      data-ad-slot="3839663239"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
</div>

<div class="header ads2">
</div>
        
            <section class="wrapper-body">

            <div class="blog-navi-left">
    <div class="container-navi-left">
    <ul class="navi-left-item">
        <li>
            <a href="/">
                <img class="navi-left" src="/assets/img/home.png" />
            </a>
        </li>
        <li>
            <a href="mailto:delacruzallanjay@gmail.com">
                <img class="navi-left" src="/assets/img/email.png" />
            </a>
        </li>
        <li>
            <a href="https://cranzblog.wordpress.com">
                <img class="navi-left" src="/assets/img/wordpress.png" />
            </a>
        </li>
    </ul>
</div>
</div>
<div class="blog">
    <div class="blog-title">
        <h2>RPi 3: GPIO on .Net Core consoleApp inside Docker using bcm2835 library: #2</h2>
    </div>
    <div class="blog-date">
        <time>06/27/17</time>
        </div>
    <div class="blog-content">
        <h3 id="gpio">GPIO</h3>
<p>Now let’s try our RPi3 GPIO. In our testapp project we created <a href="../26/rpi3-docker-gpio">earlier</a>…we’ll have a directory tree like mine:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin
/obj
testapp.csproj
Program.cs
</code></pre></div></div>

<p>Then modify <code class="highlighter-rouge">Program.cs</code> with these codes. What it does is we use <code class="highlighter-rouge">libbcm2835.so</code> C internal commands into our C# app using PInvoke.
Take note of the <code class="highlighter-rouge">PIN Numbering</code>: bcm2835 library use physical numbering so <code class="highlighter-rouge">RPI_GPIO_P1_07</code> is equal to GPIO4 of our RPi3.</p>

<p><img src="/ubuntu/images/Raspberry-Pi-3-GPIO-Layout-Model-B.jpg" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Runtime.InteropServices;

namespace testapp
{
    class Program
    {
        private static uint HIGH = 0x1;
        private static uint LOW  = 0x0;
        private static byte RPI_GPIO_P1_07 = 4;
        private static byte BCM2835_GPIO_FSEL_OUTP = 0x01;

        [DllImport("libbcm2835.so")]
        public static extern int bcm2835_init();

        [DllImport("libbcm2835.so")]
        public static extern void bcm2835_close();

        [DllImport("libbcm2835.so")]
        public static extern void bcm2835_delay(uint millis);

        [DllImport("libbcm2835.so")]
        public static extern void bcm2835_gpio_fsel(byte pin, byte mode);

        [DllImport("libbcm2835.so")]
        public static extern void bcm2835_gpio_write(byte pin, uint on);

        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");

            if (bcm2835_init() == 1)
            {
                
                    bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP);
                    
                    // Blink
                    while(true)
                    {
                        // Turn it on
                        bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH);
                        // wait
                        bcm2835_delay(500);
                        // turn it off
                        bcm2835_gpio_write(RPI_GPIO_P1_07, LOW);
                        // wait 
                        bcm2835_delay(500);
                    }
                
            }
            bcm2835_close();
        }
    }
}
</code></pre></div></div>

<p>Then publish and get our new <code class="highlighter-rouge">/publish</code> folder contents. And copy it inside our RPi3.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>testapp&gt; dotnet publish -r ubuntu.16.04-arm     //then copy /publish folder into our RPi3
</code></pre></div></div>

<p>Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header.
<code class="highlighter-rouge">Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3</code>.
In RPi3, let us run our updated docker image then test our testapp on it.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share
</code></pre></div></div>
<h6 id="note---rm--means-that-once-we-exit-docker-it-will-clean-our-previouly-runned-docker-image">Note :<code class="highlighter-rouge">--rm</code>  means that once we exit docker it will clean our previouly runned docker image.</h6>

<p><br />
Make sure that you have <code class="highlighter-rouge">libbcm2835.so</code> inside the <code class="highlighter-rouge">/lib/arm-~</code> folder or it will complain about running it in SDK.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cd /home/share/publish
/home/share/publish# /opt/dotnet/dotnet ./testapp.dll
</code></pre></div></div>

<p>Your led should be blinking right now…. <a href="../30/rpi3-docker-gpio-3">part3</a></p>

<hr />



        <!-- Comments -->
        <div class="comments">
            
    <!-- Add Disqus comments. -->
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'a-delacruz'; // required: replace example with your forum shortname
        // var disqus_developer = 1; // Comment out when the site is live
        var disqus_identifier = "/ubuntu/2017/06/27/rpi3-docker-gpio-2.html";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the
        <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by
        <span class="logo-disqus">Disqus</span>
    </a>

        </div>
    </div>
</div>

            </section>

            <script src="/assets/js/scale.fix.js"></script>
            
            <!-- Google Analytics -->
            
                <script>
                    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
                    ga('create', 'UA-99256627-1', 'auto');
                    ga('send', 'pageview');
                </script>
            
        </div>        
    </body>
    
</html>