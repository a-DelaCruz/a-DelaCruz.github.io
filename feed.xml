<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/" rel="alternate" type="text/html" /><updated>2017-07-03T20:20:25+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/</id><title type="html">My Notes on Single Board Computer</title><subtitle>Raspberry Pi 3 - 64-Bit kernel and arm64 rootfs
</subtitle><entry><title type="html">Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 4]</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/07/01/rpi3-docker-gpio-4.html" rel="alternate" type="text/html" title="Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 4]" /><published>2017-07-01T00:00:00+08:00</published><updated>2017-07-01T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/07/01/rpi3-docker-gpio-4</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/07/01/rpi3-docker-gpio-4.html">&lt;p&gt;Since we now have tested our previous scenarios… Now let’s try to translate bcm2835 library C code to C# and only importing some C functions. That means we only need to have a glibc library present in our system. There are already C# library out there… like:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/raspberry-sharp/raspberry-sharp-io&quot;&gt;Raspberry# IO&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cypherkey/RaspberryPi.Net/&quot;&gt;RaspberryPi.Net&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.raspberrypi.org/forums/viewtopic.php?f=34&amp;amp;t=152940&quot;&gt;BCM2835 port to C#&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seems fine to use with mono installed… although i never tried to use them. And i have not read all their codes on which part are the Mono part. But there are some imports C function that are common to them. Among those three, the last one is a direct port of BCM2835 library to full C# code. But still use a few Mono system calls. So for now what i did is use his codes &lt;code class=&quot;highlighter-rouge&quot;&gt;BCM2835 port to C#&lt;/code&gt;, remove and modify some of it.
So far this is what i’ve done and still not finished:&lt;/p&gt;
&lt;h4 id=&quot;some-c-functions&quot;&gt;Some C functions.&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Runtime.InteropServices;

namespace RPi3
{
    public static class Interop
    {

        #region Enum
           
            public enum OpenFlags : int // Open
            {
                O_RDWR = 2,
                O_SYNC = 10000
            }
            
            
            public enum MmapProts : int //mmap
            {
                PROT_READ = 1,  // Page can be read.
                PROT_WRITE = 2,  // Page can be written.
                PROT_EXEC = 4,  // Page can be executed.
                PROT_READWRITE = PROT_READ | PROT_WRITE
            }

            
            public enum MmapFlags : int // mmap
            {
                MAP_SHARED = 1,     // Share changes.
                MAP_PRIVATE = 2     // Changes are private.
            }

            public struct timespec  //Delay under test
            {
                public IntPtr tv_sec; /* seconds */
                public IntPtr tv_nsec; /* nanoseconds */
            }
        #endregion
        
        #region Libc
            [DllImport(&quot;libc.so.6&quot;)]
            public static extern int geteuid();

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern int open(string pathname, OpenFlags flags);

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern int close(int fd);

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern void sync();

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern IntPtr mmap(IntPtr addr, uint length, MmapProts prot, MmapFlags flags, int fd, uint offset);

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern int munmap(IntPtr addr, uint length);

            [DllImport(&quot;libc.so.6&quot;)]
            public static extern int nanosleep(ref timespec req, ref timespec rem);

        #endregion
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You must include an &lt;code class=&quot;highlighter-rouge&quot;&gt;EntryPoint&lt;/code&gt; on your &lt;code class=&quot;highlighter-rouge&quot;&gt;DllImport&lt;/code&gt; in you ever want to change its name.. like so:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[DllImport(&quot;libc.so.6&quot;, EntryPoint = &quot;open&quot;)]
private static extern IntPtr OpenSename(string pathname, OpenFlags flags);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And replace all code that use &lt;code class=&quot;highlighter-rouge&quot;&gt;Syscall&lt;/code&gt; to use this &lt;code class=&quot;highlighter-rouge&quot;&gt;Interop&lt;/code&gt; and remove Mono directive.
I also remove this code below for now: and just use it’s type pointer instead like in the orginal but without having it volatile.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public unsafe struct VolatilePointer
    {
        public volatile uint* Address;

        public VolatilePointer(uint Address)
        {
            this.Address = (uint*)Address;
        }

        public VolatilePointer(uint* Address)
        {
            this.Address = Address;
        }

        public static implicit operator VolatilePointer(uint* Address)
        {
            return new VolatilePointer(Address);
        }

        public static implicit operator VolatilePointer(uint Address)
        {
            return new VolatilePointer(Address);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So from these:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)] // &amp;lt;- I still need more time to grasp what this is for so i removed it for now
public static uint bcm2835_peri_read(VolatilePointer paddr)
{
    uint ret;

    Thread.MemoryBarrier();
    ret = *paddr.Address;
    Thread.MemoryBarrier();
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;into these:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static uint bcm2835_peri_read(uint* paddr)
{
    uint ret;

    Thread.MemoryBarrier();
    ret = *paddr;
    Thread.MemoryBarrier();
    return ret;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For simple output test these are the basic function that is needed from &lt;a href=&quot;https://www.raspberrypi.org/forums/viewtopic.php?f=34&amp;amp;t=152940&quot;&gt;BCM2835 port to C#&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bcm2835_init()
mapmem
bcm2835_peri_read
bcm2835_peri_write
bcm2835_peri_set_bits
bcm2835_gpio_fsel
bcm2835_gpio_set
bcm2835_gpio_clr
bcm2835_gpio_write
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">Since we now have tested our previous scenarios… Now let’s try to translate bcm2835 library C code to C# and only importing some C functions. That means we only need to have a glibc library present in our system. There are already C# library out there… like: Raspberry# IO RaspberryPi.Net BCM2835 port to C# Seems fine to use with mono installed… although i never tried to use them. And i have not read all their codes on which part are the Mono part. But there are some imports C function that are common to them. Among those three, the last one is a direct port of BCM2835 library to full C# code. But still use a few Mono system calls. So for now what i did is use his codes BCM2835 port to C#, remove and modify some of it. So far this is what i’ve done and still not finished: Some C functions. using System; using System.Runtime.InteropServices; namespace RPi3 { public static class Interop { #region Enum public enum OpenFlags : int // Open { O_RDWR = 2, O_SYNC = 10000 } public enum MmapProts : int //mmap { PROT_READ = 1, // Page can be read. PROT_WRITE = 2, // Page can be written. PROT_EXEC = 4, // Page can be executed. PROT_READWRITE = PROT_READ | PROT_WRITE } public enum MmapFlags : int // mmap { MAP_SHARED = 1, // Share changes. MAP_PRIVATE = 2 // Changes are private. } public struct timespec //Delay under test { public IntPtr tv_sec; /* seconds */ public IntPtr tv_nsec; /* nanoseconds */ } #endregion #region Libc [DllImport(&quot;libc.so.6&quot;)] public static extern int geteuid(); [DllImport(&quot;libc.so.6&quot;)] public static extern int open(string pathname, OpenFlags flags); [DllImport(&quot;libc.so.6&quot;)] public static extern int close(int fd); [DllImport(&quot;libc.so.6&quot;)] public static extern void sync(); [DllImport(&quot;libc.so.6&quot;)] public static extern IntPtr mmap(IntPtr addr, uint length, MmapProts prot, MmapFlags flags, int fd, uint offset); [DllImport(&quot;libc.so.6&quot;)] public static extern int munmap(IntPtr addr, uint length); [DllImport(&quot;libc.so.6&quot;)] public static extern int nanosleep(ref timespec req, ref timespec rem); #endregion } } You must include an EntryPoint on your DllImport in you ever want to change its name.. like so: [DllImport(&quot;libc.so.6&quot;, EntryPoint = &quot;open&quot;)] private static extern IntPtr OpenSename(string pathname, OpenFlags flags); And replace all code that use Syscall to use this Interop and remove Mono directive. I also remove this code below for now: and just use it’s type pointer instead like in the orginal but without having it volatile. public unsafe struct VolatilePointer { public volatile uint* Address; public VolatilePointer(uint Address) { this.Address = (uint*)Address; } public VolatilePointer(uint* Address) { this.Address = Address; } public static implicit operator VolatilePointer(uint* Address) { return new VolatilePointer(Address); } public static implicit operator VolatilePointer(uint Address) { return new VolatilePointer(Address); } } So from these: [MethodImpl(MethodImplOptions.AggressiveInlining)] // &amp;lt;- I still need more time to grasp what this is for so i removed it for now public static uint bcm2835_peri_read(VolatilePointer paddr) { uint ret; Thread.MemoryBarrier(); ret = *paddr.Address; Thread.MemoryBarrier(); return ret; } into these: public static uint bcm2835_peri_read(uint* paddr) { uint ret; Thread.MemoryBarrier(); ret = *paddr; Thread.MemoryBarrier(); return ret;; } For simple output test these are the basic function that is needed from BCM2835 port to C#: bcm2835_init() mapmem bcm2835_peri_read bcm2835_peri_write bcm2835_peri_set_bits bcm2835_gpio_fsel bcm2835_gpio_set bcm2835_gpio_clr bcm2835_gpio_write</summary></entry><entry><title type="html">Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 3]</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/30/rpi3-docker-gpio-3.html" rel="alternate" type="text/html" title="Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 3]" /><published>2017-06-30T00:00:00+08:00</published><updated>2017-06-30T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/30/rpi3-docker-gpio-3</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/30/rpi3-docker-gpio-3.html">&lt;p&gt;In our previous &lt;a href=&quot;../27/rpi3-docker-gpio-2&quot;&gt;post&lt;/a&gt;… we tried a console app. This time we’ll try a web api. So we’ll create a new project and named it &lt;code class=&quot;highlighter-rouge&quot;&gt;testWebApi&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;dotnet new piwebapi -n testWebApi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Above code runned in  windows cmd prompt because i use visual studio code as my editor. Run &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet new --help&lt;/code&gt; to see a list of available templates.
Now Open the created &lt;code class=&quot;highlighter-rouge&quot;&gt;/ControllersValuesController&lt;/code&gt; and rename it in my case to &lt;code class=&quot;highlighter-rouge&quot;&gt;TestpinController&lt;/code&gt; or just leave it as it is.
we’ll modify our code like so:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;

using System.Runtime.InteropServices;

namespace testWebApi.Controllers
{
    [Route(&quot;[controller]&quot;)]
    public class TestpinController : Controller
    {
        private static uint HIGH = 0x1;
        private static uint LOW  = 0x0;
        private static byte BCM2835_GPIO_FSEL_OUTP = 0x01;
        private static byte RPI_GPIO_P1_07 = 4;

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern int bcm2835_init();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_close();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_delay(uint millis);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_fsel(byte pin, byte mode);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_write(byte pin, uint on);

        [DllImport(&quot;libc.so.6&quot;)]
        public static extern int geteuid();

        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;value1&quot;, &quot;value2&quot; };
        }

        [HttpPost]
        public void SwitchPin(int pinId)
        {
            if(bcm2835_init() == pinId)
                bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP);

            switch (pinId)
            {
                case 1:
                    bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH);
                    break;
                case 0:
                    bcm2835_gpio_write(RPI_GPIO_P1_07, LOW);
                    break;
                default:
                    break;
            }

            bcm2835_close();
        }
        
    }
   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Just like before let’s build and publish it for ubuntu.16.04-arm. Then copy it to our RPi3;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testWebApi&amp;gt;dotnet build .
testWebApi&amp;gt;dotnet publish -r ubuntu.16.04-arm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So when we run it now inside our docker… and browse it at &lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.254.102:5000/Testpin&lt;/code&gt; we’ll have an output:
&lt;img src=&quot;/ubuntu/images/testWebApi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But we have no way of sending value &lt;code class=&quot;highlighter-rouge&quot;&gt;[HttpPost]&lt;/code&gt; to our RPi3. For that i use &lt;code class=&quot;highlighter-rouge&quot;&gt;Postman&lt;/code&gt; which is a Chrome extension app for testing Web Apis.&lt;/p&gt;

&lt;p&gt;When we send &lt;code class=&quot;highlighter-rouge&quot;&gt;Get&lt;/code&gt; command using &lt;code class=&quot;highlighter-rouge&quot;&gt;Postman&lt;/code&gt; we’ll have an output like these: Displaying the values when we use a WebBrowser.
&lt;img src=&quot;/ubuntu/images/Postman-Get.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In order to send a value to our Rpi3… Well use &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; then click &lt;code class=&quot;highlighter-rouge&quot;&gt;Params&lt;/code&gt; right before &lt;code class=&quot;highlighter-rouge&quot;&gt;SEND&lt;/code&gt;. On the &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; column type &lt;code class=&quot;highlighter-rouge&quot;&gt;pinId&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; for HIGH[led on] and &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; for LOW[led off]. On our first &lt;code class=&quot;highlighter-rouge&quot;&gt;Send&lt;/code&gt;…our RPi3 will complain a &lt;code class=&quot;highlighter-rouge&quot;&gt;fail&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Postman&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Status:500 Internal Server Error&lt;/code&gt;. for now i don’t know how to fixe this.
&lt;img src=&quot;/ubuntu/images/Postman-Post-1.jpg&quot; alt=&quot;&quot; /&gt;
But if we press &lt;code class=&quot;highlighter-rouge&quot;&gt;Send&lt;/code&gt; again…. it works, our led is light up and and a &lt;code class=&quot;highlighter-rouge&quot;&gt;Status:200 OK&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;Postman&lt;/code&gt;.
&lt;img src=&quot;/ubuntu/images/Postman-Post-2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;On to &lt;a href=&quot;../../07/01/rpi3-docker-gpio-4&quot;&gt;part4&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">In our previous post… we tried a console app. This time we’ll try a web api. So we’ll create a new project and named it testWebApi. &amp;gt;dotnet new piwebapi -n testWebApi Above code runned in windows cmd prompt because i use visual studio code as my editor. Run dotnet new --help to see a list of available templates. Now Open the created /ControllersValuesController and rename it in my case to TestpinController or just leave it as it is. we’ll modify our code like so: using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using System.Runtime.InteropServices; namespace testWebApi.Controllers { [Route(&quot;[controller]&quot;)] public class TestpinController : Controller { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; private static byte RPI_GPIO_P1_07 = 4; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); [DllImport(&quot;libc.so.6&quot;)] public static extern int geteuid(); [HttpGet] public IEnumerable&amp;lt;string&amp;gt; Get() { return new string[] { &quot;value1&quot;, &quot;value2&quot; }; } [HttpPost] public void SwitchPin(int pinId) { if(bcm2835_init() == pinId) bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); switch (pinId) { case 1: bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); break; case 0: bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); break; default: break; } bcm2835_close(); } } } Just like before let’s build and publish it for ubuntu.16.04-arm. Then copy it to our RPi3; testWebApi&amp;gt;dotnet build . testWebApi&amp;gt;dotnet publish -r ubuntu.16.04-arm So when we run it now inside our docker… and browse it at http://192.168.254.102:5000/Testpin we’ll have an output: But we have no way of sending value [HttpPost] to our RPi3. For that i use Postman which is a Chrome extension app for testing Web Apis. When we send Get command using Postman we’ll have an output like these: Displaying the values when we use a WebBrowser. In order to send a value to our Rpi3… Well use POST then click Params right before SEND. On the key column type pinId and a Value of 1 for HIGH[led on] and 0 for LOW[led off]. On our first Send…our RPi3 will complain a fail and Postman Status:500 Internal Server Error. for now i don’t know how to fixe this. But if we press Send again…. it works, our led is light up and and a Status:200 OK in Postman. On to part4</summary></entry><entry><title type="html">Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 2]</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/27/rpi3-docker-gpio-2.html" rel="alternate" type="text/html" title="Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 2]" /><published>2017-06-27T00:00:00+08:00</published><updated>2017-06-27T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/27/rpi3-docker-gpio-2</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/27/rpi3-docker-gpio-2.html">&lt;h3 id=&quot;-gpio&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt; GPIO&lt;/h3&gt;
&lt;p&gt;Now let’s try our RPi3 GPIO. In our testapp project we created &lt;a href=&quot;../26/rpi3-docker-gpio&quot;&gt;earlier&lt;/a&gt;…we’ll have a directory tree like mine:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/bin
/obj
testapp.csproj
Program.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then modify &lt;code class=&quot;highlighter-rouge&quot;&gt;Program.cs&lt;/code&gt; with these codes. What it does is we use &lt;code class=&quot;highlighter-rouge&quot;&gt;libbcm2835.so&lt;/code&gt; C internal commands into our C# app using PInvoke.
Take note of the &lt;code class=&quot;highlighter-rouge&quot;&gt;PIN Numbering&lt;/code&gt;: bcm2835 library use physical numbering so &lt;code class=&quot;highlighter-rouge&quot;&gt;RPI_GPIO_P1_07&lt;/code&gt; is equal to GPIO4 of our RPi3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ubuntu/images/Raspberry-Pi-3-GPIO-Layout-Model-B.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using System;
using System.Runtime.InteropServices;

namespace testapp
{
    class Program
    {
        private static uint HIGH = 0x1;
        private static uint LOW  = 0x0;
        private static byte RPI_GPIO_P1_07 = 4;
        private static byte BCM2835_GPIO_FSEL_OUTP = 0x01;

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern int bcm2835_init();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_close();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_delay(uint millis);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_fsel(byte pin, byte mode);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_write(byte pin, uint on);

        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Hello World!&quot;);

            if (bcm2835_init() == 1)
            {
                
                    bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP);
                    
                    // Blink
                    while(true)
                    {
                        // Turn it on
                        bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH);
                        // wait
                        bcm2835_delay(500);
                        // turn it off
                        bcm2835_gpio_write(RPI_GPIO_P1_07, LOW);
                        // wait 
                        bcm2835_delay(500);
                    }
                
            }
            bcm2835_close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then publish and get our new &lt;code class=&quot;highlighter-rouge&quot;&gt;/publish&lt;/code&gt; folder contents. And copy it inside our RPi3.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testapp&amp;gt; dotnet publish -r ubuntu.16.04-arm     //then copy /publish folder into our RPi3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3&lt;/code&gt;.
In RPi3, let us run our updated docker image then test our testapp on it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;note---rm--means-that-once-we-exit-docker-it-will-clean-our-previouly-runned-docker-image&quot;&gt;Note :&lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt;  means that once we exit docker it will clean our previouly runned docker image.&lt;/h6&gt;

&lt;p&gt;Make sure that you have &lt;code class=&quot;highlighter-rouge&quot;&gt;libbcm2835.so&lt;/code&gt; inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/arm-~&lt;/code&gt; folder or it will complain about running it in SDK.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cd /home/share/publish
/home/share/publish# /opt/dotnet/dotnet ./testapp.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Your led should be blinking right now…. &lt;a href=&quot;../30/rpi3-docker-gpio-3&quot;&gt;part3&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">GPIO Now let’s try our RPi3 GPIO. In our testapp project we created earlier…we’ll have a directory tree like mine: /bin /obj testapp.csproj Program.cs Then modify Program.cs with these codes. What it does is we use libbcm2835.so C internal commands into our C# app using PInvoke. Take note of the PIN Numbering: bcm2835 library use physical numbering so RPI_GPIO_P1_07 is equal to GPIO4 of our RPi3. using System; using System.Runtime.InteropServices; namespace testapp { class Program { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte RPI_GPIO_P1_07 = 4; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); if (bcm2835_init() == 1) { bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); // Blink while(true) { // Turn it on bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); // wait bcm2835_delay(500); // turn it off bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); // wait bcm2835_delay(500); } } bcm2835_close(); } } } Then publish and get our new /publish folder contents. And copy it inside our RPi3. testapp&amp;gt; dotnet publish -r ubuntu.16.04-arm //then copy /publish folder into our RPi3 Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. Please be careful and you should know how to properly hook up our test led to avoid breaking our RPi3. In RPi3, let us run our updated docker image then test our testapp on it. $ sudo docker run -it --privileged --rm -p 5000:5000 -v /home/pi3:/home/share Note :--rm means that once we exit docker it will clean our previouly runned docker image. Make sure that you have libbcm2835.so inside the /lib/arm-~ folder or it will complain about running it in SDK. # cd /home/share/publish /home/share/publish# /opt/dotnet/dotnet ./testapp.dll Your led should be blinking right now…. part3</summary></entry><entry><title type="html">Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 1]</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/26/rpi3-docker-gpio.html" rel="alternate" type="text/html" title="Raspberry Pi 3: simple GPIO on .Net Core inside Docker using bcm2835 library:[part 1]" /><published>2017-06-26T00:00:00+08:00</published><updated>2017-06-26T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/26/rpi3-docker-gpio</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/26/rpi3-docker-gpio.html">&lt;p&gt;I wan’t to try .Net Core on linux-arm64… but unfortunately, there’s no available yet except Win-arm64 and linux-arm32. So instead of using qemu for VM inside RPi3… i encounter docker and try it out. For now i’ll use ubuntu-arm32 as the base image then later try alpine-linux.&lt;/p&gt;

&lt;h4 id=&quot;prerequisites&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Prerequisites:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/core-setup/files/716356/dotnet-ubuntu.16.04-arm.1.2.0-beta-001291-00.tar.gz&quot;&gt;dotnet-runtime-latest-linux-arm.tar.gz&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.airspayce.com/mikem/bcm2835/bcm2835-1.52.tar.gz&quot;&gt;bcm2835-1.52.tar.gz&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.Net Core SDK&lt;/code&gt;     // on your developtment host&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libbcm2835.so&lt;/code&gt;     // We’ll create from bcm2835-library&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io&lt;/code&gt;         // To be installed on our RPi3&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;              // To be installed inside docker&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;              // To be installed inside docker&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-container&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt;Docker Container&lt;/h3&gt;
&lt;p&gt;Assuming you already install &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io&lt;/code&gt;. Go ahead and pull an armhf/ubuntu image to be use.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker pull armhf/ubuntu     //This is what i use for now
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then run it using these command:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -it --privileged -p 5000:5000 -v /home/user:/home/share armhf/ubuntu
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;note-docker-options-that-well-use&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Note: Docker options that we’ll use:&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-it
-v  /[folder to share]:/[folder destination]
-p  5000:5000   //port to expose. [any port you like on host]:[any port you'll set on .net core]
--privileged    //to have acces on /dev/mem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then install these packages for &lt;code class=&quot;highlighter-rouge&quot;&gt;.Net Core&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# apt-get install libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev uuid-dev
# apt-get install make gcc      // can be remove after we created our libbcm2835.so
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We’re going to extract &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet-runtime-latest-linux-arm.tar.gz&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/dotnet&lt;/code&gt; folder.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir /opt/dotnet
# tar -zxvf dotnet-runtime-latest-linux-arm.tar.gz -C /opt/dotnet
# /opt/dotnet/dotnet    //Then run this to check that it works. or ./dotnet inside the dotnet folder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Extract &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2835-1.52.tar.gz&lt;/code&gt; anywhere you like, because where going to remove it once we have &lt;code class=&quot;highlighter-rouge&quot;&gt;libbcm2835.so&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tar -zxvf bcm2835-1.52.tar.gz
# cd bcm2835-1.52/src
# gcc -fPIC -c bcm2835.c
# gcc -shared bcm2835.o -o libbcm2835.so
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can now remove the &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2835-1.52 folder&lt;/code&gt; and be sure to put &lt;code class=&quot;highlighter-rouge&quot;&gt;libbcm2835.so&lt;/code&gt; inside &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/arm-&lt;/code&gt; folder.
And now lets exit docker and save our updated docker image.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# exit
$ sudo docker commit $(sudo docker ps -aq) armhf/ubuntu     // # sudo docker ps -aq get the id of the docker image we just exited.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;-net-core&quot;&gt;&lt;a href=&quot;#header-3&quot;&gt;&lt;/a&gt; .Net Core&lt;/h3&gt;
&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;.Net Core SDK&lt;/code&gt; is installed, create a simple console application that we can try to test first. I use windows for development. So from cmd prompt i ran this command to create a test app.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; dotnet new console -n testapp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then make sure the we have the same configuration like this for our test app in &lt;code class=&quot;highlighter-rouge&quot;&gt;testapp.csproj&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Project&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Sdk=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PropertyGroup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;OutputType&amp;gt;&lt;/span&gt;Exe&lt;span class=&quot;nt&quot;&gt;&amp;lt;/OutputType&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;TargetFramework&amp;gt;&lt;/span&gt;netcoreapp2.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/TargetFramework&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;RuntimeFrameworkVersion&amp;gt;&lt;/span&gt;2.0.0-preview1-002028-00&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RuntimeFrameworkVersion&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;RuntimeIdentifiers&amp;gt;&lt;/span&gt;ubuntu.16.04-arm&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RuntimeIdentifiers&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/PropertyGroup&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Project&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For now aside from the above… we’ll leave everything as it is and then run these commands:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cd testapp
testapp&amp;gt; dotnet restore .
testapp&amp;gt; dotnet build .
testapp&amp;gt; dotnet publish -r ubuntu.16.04-arm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The command &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet publish -r ubuntu.16.04-arm&lt;/code&gt; will create the necessary files that we need to run our console app in ubuntu.
Now let’s go to: &lt;code class=&quot;highlighter-rouge&quot;&gt;/testapp/bin/debug/netcoreapp2.0/ubuntu.16.04-arm&lt;/code&gt; folder and the &lt;code class=&quot;highlighter-rouge&quot;&gt;/publish folder&lt;/code&gt; is what we need to copy into our RPi3. You can use any SFTP app you like to do it. Once your done transfering that folder… let’s navigate into it and test if it will run. let us run again our docker image above and then In my case i’ll use this as my shared folder: &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/pi3:/home/share&lt;/code&gt; [my RPi3 folder]:[docker folder that is created automatically]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -it --privileged -p 5000:5000 -v /home/pi3:/home/share armhf/ubuntu
# cd /home/share/publish
# /opt/dotnet/dotnet ./testapp.dll

    Hellow World!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Those last 2 commands are run inside the docker image. Yes! it’s alive…Now for the &lt;a href=&quot;../27/rpi3-docker-gpio-2&quot;&gt;part 2&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;reference&quot;&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dotnetcorechris.github.io/dotnetcoreonraspberrypi.html&quot;&gt;https://dotnetcorechris.github.io/dotnetcoreonraspberrypi.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html&quot;&gt;http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jeremylindsayni.wordpress.com/2017/04/02/installing-ubuntu-16-04-on-a-raspberry-pi-3-installing-net-core-2-and-running-a-sample-net-core-2-app/&quot;&gt;https://jeremylindsayni.wordpress.com/2017/04/02/installing-ubuntu-16-04-on-a-raspberry-pi-3-installing-net-core-2-and-running-a-sample-net-core-2-app/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">I wan’t to try .Net Core on linux-arm64… but unfortunately, there’s no available yet except Win-arm64 and linux-arm32. So instead of using qemu for VM inside RPi3… i encounter docker and try it out. For now i’ll use ubuntu-arm32 as the base image then later try alpine-linux. Prerequisites: dotnet-runtime-latest-linux-arm.tar.gz bcm2835-1.52.tar.gz .Net Core SDK // on your developtment host libbcm2835.so // We’ll create from bcm2835-library docker.io // To be installed on our RPi3 make // To be installed inside docker gcc // To be installed inside docker Docker Container Assuming you already install docker.io. Go ahead and pull an armhf/ubuntu image to be use. $ sudo docker pull armhf/ubuntu //This is what i use for now Then run it using these command: $ sudo docker run -it --privileged -p 5000:5000 -v /home/user:/home/share armhf/ubuntu Note: Docker options that we’ll use: -it -v /[folder to share]:/[folder destination] -p 5000:5000 //port to expose. [any port you like on host]:[any port you'll set on .net core] --privileged //to have acces on /dev/mem Then install these packages for .Net Core: # apt-get install libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev uuid-dev # apt-get install make gcc // can be remove after we created our libbcm2835.so We’re going to extract dotnet-runtime-latest-linux-arm.tar.gz in /opt/dotnet folder. # mkdir /opt/dotnet # tar -zxvf dotnet-runtime-latest-linux-arm.tar.gz -C /opt/dotnet # /opt/dotnet/dotnet //Then run this to check that it works. or ./dotnet inside the dotnet folder Extract bcm2835-1.52.tar.gz anywhere you like, because where going to remove it once we have libbcm2835.so. # tar -zxvf bcm2835-1.52.tar.gz # cd bcm2835-1.52/src # gcc -fPIC -c bcm2835.c # gcc -shared bcm2835.o -o libbcm2835.so You can now remove the bcm2835-1.52 folder and be sure to put libbcm2835.so inside /lib/arm- folder. And now lets exit docker and save our updated docker image. # exit $ sudo docker commit $(sudo docker ps -aq) armhf/ubuntu // # sudo docker ps -aq get the id of the docker image we just exited. .Net Core Once .Net Core SDK is installed, create a simple console application that we can try to test first. I use windows for development. So from cmd prompt i ran this command to create a test app. &amp;gt; dotnet new console -n testapp Then make sure the we have the same configuration like this for our test app in testapp.csproj: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt; &amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt; &amp;lt;TargetFramework&amp;gt;netcoreapp2.0&amp;lt;/TargetFramework&amp;gt; &amp;lt;RuntimeFrameworkVersion&amp;gt;2.0.0-preview1-002028-00&amp;lt;/RuntimeFrameworkVersion&amp;gt; &amp;lt;RuntimeIdentifiers&amp;gt;ubuntu.16.04-arm&amp;lt;/RuntimeIdentifiers&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;/Project&amp;gt; For now aside from the above… we’ll leave everything as it is and then run these commands: &amp;gt; cd testapp testapp&amp;gt; dotnet restore . testapp&amp;gt; dotnet build . testapp&amp;gt; dotnet publish -r ubuntu.16.04-arm The command dotnet publish -r ubuntu.16.04-arm will create the necessary files that we need to run our console app in ubuntu. Now let’s go to: /testapp/bin/debug/netcoreapp2.0/ubuntu.16.04-arm folder and the /publish folder is what we need to copy into our RPi3. You can use any SFTP app you like to do it. Once your done transfering that folder… let’s navigate into it and test if it will run. let us run again our docker image above and then In my case i’ll use this as my shared folder: /home/pi3:/home/share [my RPi3 folder]:[docker folder that is created automatically] $ sudo docker run -it --privileged -p 5000:5000 -v /home/pi3:/home/share armhf/ubuntu # cd /home/share/publish # /opt/dotnet/dotnet ./testapp.dll Hellow World! Those last 2 commands are run inside the docker image. Yes! it’s alive…Now for the part 2 Reference: https://dotnetcorechris.github.io/dotnetcoreonraspberrypi.html http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html https://jeremylindsayni.wordpress.com/2017/04/02/installing-ubuntu-16-04-on-a-raspberry-pi-3-installing-net-core-2-and-running-a-sample-net-core-2-app/</summary></entry><entry><title type="html">Raspberry Pi 3: Bluetooth Setup</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/16/rpi3-bluetooth-setup.html" rel="alternate" type="text/html" title="Raspberry Pi 3: Bluetooth Setup" /><published>2017-06-16T00:00:00+08:00</published><updated>2017-06-16T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/16/rpi3-bluetooth-setup</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/06/16/rpi3-bluetooth-setup.html">&lt;p&gt;In order for the Bluetooth to work.. we need to have this file.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OpenELEC/misc-firmware/blob/master/firmware/brcm/BCM43430A1.hcd&quot;&gt;BCM43430A1.hcd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Make sure this are installed:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;bluetooth&lt;/li&gt;
  &lt;li&gt;bluez&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put this file: &lt;code class=&quot;highlighter-rouge&quot;&gt;BCM43430A1.hcd&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/firmware/brcm&lt;/code&gt; folder… then create a symlink of it in &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/firmware&lt;/code&gt; folder.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mkdir /etc/firmware
$ sudo ln -s /lib/firmware/brcm/BCM43430A1.hcd /etc/firmware/BCM43430A1.hcd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then to test it.. run this twice:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo /usr/bin/hciattach /dev/ttyAMA0 bc43xx 921600 noflow
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;First run we’ll encouter &lt;code class=&quot;highlighter-rouge&quot;&gt;Initialization timed out&lt;/code&gt;. But on the second time we’ll get this &lt;code class=&quot;highlighter-rouge&quot;&gt;Device setup complete&lt;/code&gt;.
Then try it out now if our device is present.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hcitool dev

    Devices:
        hci0   [your device id shows here]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then run your friendly &lt;code class=&quot;highlighter-rouge&quot;&gt;bluetoothctl&lt;/code&gt;. To automate this at boot, just follow the scripts from the reference below.&lt;/p&gt;

&lt;h5 id=&quot;reference&quot;&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.adelpha.be/blog/index.php/2016/09/24/raspberry-pi-3-native-wifi-and-bluetooth/&quot;&gt;http://www.adelpha.be/blog/index.php/2016/09/24/raspberry-pi-3-native-wifi-and-bluetooth/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xbianonpi/xbian/issues/813&quot;&gt;https://github.com/xbianonpi/xbian/issues/813&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">In order for the Bluetooth to work.. we need to have this file. BCM43430A1.hcd Make sure this are installed: bluetooth bluez Put this file: BCM43430A1.hcd in /lib/firmware/brcm folder… then create a symlink of it in /etc/firmware folder. $ sudo mkdir /etc/firmware $ sudo ln -s /lib/firmware/brcm/BCM43430A1.hcd /etc/firmware/BCM43430A1.hcd Then to test it.. run this twice: $ sudo /usr/bin/hciattach /dev/ttyAMA0 bc43xx 921600 noflow First run we’ll encouter Initialization timed out. But on the second time we’ll get this Device setup complete. Then try it out now if our device is present. $ hcitool dev Devices: hci0 [your device id shows here] Then run your friendly bluetoothctl. To automate this at boot, just follow the scripts from the reference below. Reference: http://www.adelpha.be/blog/index.php/2016/09/24/raspberry-pi-3-native-wifi-and-bluetooth/ https://github.com/xbianonpi/xbian/issues/813</summary></entry><entry><title type="html">Raspberry Pi 3 Alpine Linux arm64</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/alpine/2017/06/15/alpine-linux.html" rel="alternate" type="text/html" title="Raspberry Pi 3 Alpine Linux arm64" /><published>2017-06-15T00:00:00+08:00</published><updated>2017-06-15T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/alpine/2017/06/15/alpine-linux</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/alpine/2017/06/15/alpine-linux.html">&lt;p&gt;As i was been busy studying and learning about Docker and how nice it is to use Alpine linux as the docker image because of it being small in size… unlike using ubuntu as a docker image file…This time… i decided to try Alpine linux on Raspberry Pi 3.&lt;/p&gt;

&lt;h4 id=&quot;prerequisites&quot;&gt;Prerequisites:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Alpine linux Generic Arm - &lt;a href=&quot;https://nl.alpinelinux.org/alpine/v3.6/releases/aarch64/alpine-uboot-3.6.1-aarch64.tar.gz&quot;&gt;aarch64&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;For the kernel and U-boot…just follow my previous &lt;a href=&quot;rpi3-64bit-kernel-and-Uboot-booting-up&quot;&gt;post&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;note-enable-squashfs-support--file-systems---miscellaneous-filesystems----squashfs-40&quot;&gt;Note: Enable Squashfs support @ File systems -&amp;gt; Miscellaneous filesystems -&amp;gt; &amp;lt;*&amp;gt; SquashFS 4.0&lt;/h4&gt;

&lt;p&gt;The files that we need from alpine to modify is &lt;code class=&quot;highlighter-rouge&quot;&gt;initramfs-vanilla&lt;/code&gt;, and a copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;apk&lt;/code&gt; folder (&lt;code class=&quot;highlighter-rouge&quot;&gt;alpine.apkovl.tar.gz&lt;/code&gt; is optional). so go ahead and extract them.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initramfs-vanilla&lt;/code&gt; is a compressed cpio archive. To extract it we do this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir temp
$ cd temp
$ sudo gunzip -c /boot/initramfs-vanilla | cpio -i
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then we need to install our latest modules into it…assuming you already compiled kernel 4.11. following this &lt;a href=&quot;rpi3-64bit-kernel-and-Uboot-booting-up&quot;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make modules_install INSTALL_MOD_PATH=../temp/
        when it is done go back to /temp/ folder where we extract the initramfs and into the modules folder.
$ cd temp/lib/modules/
        and remove the kernel previous version and optional: the build, source folder symlink in temp/lib/modules/4.11~/ folder
$ sudo rm -rf 4.9~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we have our custom initramfs and then recreate the compressed cpio archive again.
Inside the folder run:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo find . | cpio -H newc -o | gzip -9 &amp;gt; [file destination]/initramfs-rpi3-cpio
$ cd ..
$ sudo mkimage -A arm64 -O linux -T ramdisk -d initramfs-rpi3-cpio initramfs-rpi3 // For U-boot
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modloop-vanilla&lt;/code&gt; is a squashfs file. We can make from scratch or unsquash it using this command:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo unsquashfs -f -d [file destination] [file location]/file.squashfs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To create our own &lt;code class=&quot;highlighter-rouge&quot;&gt;modloop&lt;/code&gt; file let start by making a folder&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mkdir modules // Then inside this module, let's install again our rpi-4.11y modules from above
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After you’ve installed &lt;code class=&quot;highlighter-rouge&quot;&gt;our modules from above&lt;/code&gt; on the modules folder that we’ve just created.. you’ll have a folder structure like so:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/modules
        |- /lib
                |- /firmware    // firmware_install INSTALL_FW_PATH=[in this location or just use from the moodlop-vanilla] 
                |- /modules     // again remove build and source symlink folder here
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rearrange above modules folder to:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/modules/modules/firmware
/modules/modules/4.11~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Squash it using this command:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mksquashfs [folder to be squash] [filename] -comp [compression method: I use 'xz' -Xdict-size 100%
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And now we have our own &lt;code class=&quot;highlighter-rouge&quot;&gt;initramfs-rpi3&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;modloop-rpi3&lt;/code&gt;. Our µsd card should now look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/apk
/boot/Image
/boot/kernel8.img
/boot/boot.scr
/boot/initramfs-rpi3
/boot/modloop-rpi3
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We’ll modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmdline.txt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;boot.scr&lt;/code&gt; for alpine linux.&lt;/p&gt;
&lt;h5 id=&quot;cmdlinetxt&quot;&gt;cmdline.txt&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modules=loop,squashfs,sd-mod,usb-storage quiet net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 fsck.repair=yes rootwait
// the quiet command can be remove: it just hide the message buffer of kernel. `ttyS0` can be replace by `ttyAMA0`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;bootscr&quot;&gt;boot.scr&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fdt addr 0x100
fdt get value bootargs /chosen bootargs
setenv kernel_addr_r 0x01000000
setenv ramdisk_addr_r 0x02100000
fatload mmc 0:1 ${kernel_addr_r} boot/Image
fatload mmc 0:1 ${ramdisk_addr_r} boot/initramfs-rpi3
setenv initrdsize $filesize
fatload mmc 0:1 ${fdt_addr_r} bcm2710-rpi-3-b.dtb
booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Go ahead noew and try to boot it up. You should have an output like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/alpine/images/alpine-linux-arm64-rpi3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see… there’s a hwclock error since our raspberry pi 3 don’t have any. So after you run &lt;code class=&quot;highlighter-rouge&quot;&gt;setup-alpine&lt;/code&gt; and use &lt;code class=&quot;highlighter-rouge&quot;&gt;lbu commit &lt;/code&gt; to save changes…run this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rc-update add swclock boot    # enable the software clock
rc-update del hwclock boot    # disable the hardware clock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In my case i use &lt;code class=&quot;highlighter-rouge&quot;&gt;Busybox NTP&lt;/code&gt; as it might be the most lightweight solution. Save the changes and reboot.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lbu commit
reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;wifi&quot;&gt;Wifi:&lt;/h4&gt;
&lt;p&gt;I didn’t include the &lt;code class=&quot;highlighter-rouge&quot;&gt;brcm&lt;/code&gt; above because i encouter a &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmf_sdio_htclk&lt;/code&gt; error but can be resolve by reloading the module: &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac&lt;/code&gt;
The good thing about alpine linux is if you make a &lt;code class=&quot;highlighter-rouge&quot;&gt;firmware folder&lt;/code&gt; on the root directory of our µsd card, it’ll be recognized by alpine and load it once alpine boot up. Don’t worry if the rest of the folder inside the OS fimrware folder is gone(it’s  just hidden in plain site). So i place my brcm folder there for now.&lt;/p&gt;

&lt;p&gt;According to alpine linux… &lt;a href=&quot;https://wiki.alpinelinux.org/wiki/Connecting_to_a_wireless_access_point&quot;&gt;Connecting to a wireless access point&lt;/a&gt; Broadcom Wi-Fi Chipset Users: we need &lt;code class=&quot;highlighter-rouge&quot;&gt;b43-firmware&lt;/code&gt; so go ahead and follow that or we can compile it somewhere else like what i did.&lt;/p&gt;

&lt;p&gt;On ubuntu 16.04 i install &lt;code class=&quot;highlighter-rouge&quot;&gt;b43-fwcutter&lt;/code&gt; then get &lt;a href=&quot;http://mirror2.openwrt.org/sources/broadcom-wl-4.150.10.5.tar.bz2&quot;&gt;b43-firmware&lt;/a&gt; and follow the instruction &lt;a href=&quot;http://linuxwireless.org/en/users/Drivers/b43/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar -xjf broadcom-wl-4.150.10.5.tar.bz2       // make sure bzip is installed
$ b43-fwcutter -w [$FIRMWARE_INSTALL_DIR/b43] broadcom-wl-4.150.10.5/driver/wl_apsta_mimo.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then copy that &lt;code class=&quot;highlighter-rouge&quot;&gt;b43&lt;/code&gt; folder to firmware folder on the root of our µsd card.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/apk
/boot/Image
/boot/kernel8.img
/boot/boot.scr
/boot/initramfs-rpi3
/boot/modloop-rpi3
/firmware/b43
/firmware/brcm
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Load the &lt;code class=&quot;highlighter-rouge&quot;&gt;b43&lt;/code&gt; kernel and enable it at boot up:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modprobe b43
$ echo b43 &amp;gt;&amp;gt; /etc/modules
$ lbu commit    //To save changes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you run &lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt; command and display a brcmfmac error just reload &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac module&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modprobe -r brcmfmac  // For now
$ modprobe brcmfmac
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Feedback is at most welcome…&lt;/p&gt;

&lt;h5 id=&quot;reference&quot;&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;http://backreference.org/2010/07/04/modifying-initrdinitramfs-files/&lt;/li&gt;
  &lt;li&gt;https://askubuntu.com/questions/437880/extract-a-squashfs-to-an-existing-directory&lt;/li&gt;
  &lt;li&gt;https://wiki.alpinelinux.org/wiki/DIY_Fully_working_Alpine_Linux_for_Allwinner_and_Other_ARM_SOCs&lt;/li&gt;
  &lt;li&gt;https://wiki.alpinelinux.org/wiki/Raspberry_Pi&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="alpine" /><summary type="html">As i was been busy studying and learning about Docker and how nice it is to use Alpine linux as the docker image because of it being small in size… unlike using ubuntu as a docker image file…This time… i decided to try Alpine linux on Raspberry Pi 3. Prerequisites: Alpine linux Generic Arm - aarch64 For the kernel and U-boot…just follow my previous post. Note: Enable Squashfs support @ File systems -&amp;gt; Miscellaneous filesystems -&amp;gt; &amp;lt;*&amp;gt; SquashFS 4.0 The files that we need from alpine to modify is initramfs-vanilla, and a copy of apk folder (alpine.apkovl.tar.gz is optional). so go ahead and extract them. initramfs-vanilla is a compressed cpio archive. To extract it we do this: $ mkdir temp $ cd temp $ sudo gunzip -c /boot/initramfs-vanilla | cpio -i Then we need to install our latest modules into it…assuming you already compiled kernel 4.11. following this post. $ sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make modules_install INSTALL_MOD_PATH=../temp/ when it is done go back to /temp/ folder where we extract the initramfs and into the modules folder. $ cd temp/lib/modules/ and remove the kernel previous version and optional: the build, source folder symlink in temp/lib/modules/4.11~/ folder $ sudo rm -rf 4.9~ Now we have our custom initramfs and then recreate the compressed cpio archive again. Inside the folder run: $ sudo find . | cpio -H newc -o | gzip -9 &amp;gt; [file destination]/initramfs-rpi3-cpio $ cd .. $ sudo mkimage -A arm64 -O linux -T ramdisk -d initramfs-rpi3-cpio initramfs-rpi3 // For U-boot modloop-vanilla is a squashfs file. We can make from scratch or unsquash it using this command: $ sudo unsquashfs -f -d [file destination] [file location]/file.squashfs To create our own modloop file let start by making a folder $ sudo mkdir modules // Then inside this module, let's install again our rpi-4.11y modules from above After you’ve installed our modules from above on the modules folder that we’ve just created.. you’ll have a folder structure like so: /modules |- /lib |- /firmware // firmware_install INSTALL_FW_PATH=[in this location or just use from the moodlop-vanilla] |- /modules // again remove build and source symlink folder here Rearrange above modules folder to: /modules/modules/firmware /modules/modules/4.11~ Squash it using this command: $ sudo mksquashfs [folder to be squash] [filename] -comp [compression method: I use 'xz' -Xdict-size 100% And now we have our own initramfs-rpi3 and modloop-rpi3. Our µsd card should now look like this: /apk /boot/Image /boot/kernel8.img /boot/boot.scr /boot/initramfs-rpi3 /boot/modloop-rpi3 bcm2710-rpi-3-b.dtb bootcode.bin start.elf fixup.dat config.txt cmdline.txt alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux We’ll modify the cmdline.txt and boot.scr for alpine linux. cmdline.txt modules=loop,squashfs,sd-mod,usb-storage quiet net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 fsck.repair=yes rootwait // the quiet command can be remove: it just hide the message buffer of kernel. `ttyS0` can be replace by `ttyAMA0` boot.scr fdt addr 0x100 fdt get value bootargs /chosen bootargs setenv kernel_addr_r 0x01000000 setenv ramdisk_addr_r 0x02100000 fatload mmc 0:1 ${kernel_addr_r} boot/Image fatload mmc 0:1 ${ramdisk_addr_r} boot/initramfs-rpi3 setenv initrdsize $filesize fatload mmc 0:1 ${fdt_addr_r} bcm2710-rpi-3-b.dtb booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r} Go ahead noew and try to boot it up. You should have an output like this: As you can see… there’s a hwclock error since our raspberry pi 3 don’t have any. So after you run setup-alpine and use lbu commit to save changes…run this: rc-update add swclock boot # enable the software clock rc-update del hwclock boot # disable the hardware clock In my case i use Busybox NTP as it might be the most lightweight solution. Save the changes and reboot. lbu commit reboot Wifi: I didn’t include the brcm above because i encouter a brcmf_sdio_htclk error but can be resolve by reloading the module: brcmfmac The good thing about alpine linux is if you make a firmware folder on the root directory of our µsd card, it’ll be recognized by alpine and load it once alpine boot up. Don’t worry if the rest of the folder inside the OS fimrware folder is gone(it’s just hidden in plain site). So i place my brcm folder there for now. According to alpine linux… Connecting to a wireless access point Broadcom Wi-Fi Chipset Users: we need b43-firmware so go ahead and follow that or we can compile it somewhere else like what i did. On ubuntu 16.04 i install b43-fwcutter then get b43-firmware and follow the instruction here $ tar -xjf broadcom-wl-4.150.10.5.tar.bz2 // make sure bzip is installed $ b43-fwcutter -w [$FIRMWARE_INSTALL_DIR/b43] broadcom-wl-4.150.10.5/driver/wl_apsta_mimo.o Then copy that b43 folder to firmware folder on the root of our µsd card. /apk /boot/Image /boot/kernel8.img /boot/boot.scr /boot/initramfs-rpi3 /boot/modloop-rpi3 /firmware/b43 /firmware/brcm bcm2710-rpi-3-b.dtb bootcode.bin start.elf fixup.dat config.txt cmdline.txt alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux Load the b43 kernel and enable it at boot up: $ modprobe b43 $ echo b43 &amp;gt;&amp;gt; /etc/modules $ lbu commit //To save changes If you run dmesg command and display a brcmfmac error just reload brcmfmac module: $ modprobe -r brcmfmac // For now $ modprobe brcmfmac Feedback is at most welcome… Reference: http://backreference.org/2010/07/04/modifying-initrdinitramfs-files/ https://askubuntu.com/questions/437880/extract-a-squashfs-to-an-existing-directory https://wiki.alpinelinux.org/wiki/DIY_Fully_working_Alpine_Linux_for_Allwinner_and_Other_ARM_SOCs https://wiki.alpinelinux.org/wiki/Raspberry_Pi</summary></entry><entry><title type="html">Raspberry Pi 3: Wifi Setup</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/17/rpi3-wifi-setup.html" rel="alternate" type="text/html" title="Raspberry Pi 3: Wifi Setup" /><published>2017-05-17T00:00:00+08:00</published><updated>2017-05-17T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/17/rpi3-wifi-setup</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/17/rpi3-wifi-setup.html">&lt;p&gt;To make the Raspberry pi 3 Wifi to work…we need to get or have atleast 2 files. But first we must create a
folder inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/firmware/&lt;/code&gt; and name it &lt;code class=&quot;highlighter-rouge&quot;&gt;brcm&lt;/code&gt;. And in that folder we’ll put
&lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac43430-sdio.bin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac43430-sdio.txt&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;prerequisite&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Prerequisite:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/RPi-Distro/firmware-nonfree/tree/master/brcm80211/brcm&quot;&gt;brcmfmac43430-sdio.bin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/RPi-Distro/firmware-nonfree/tree/master/brcm80211/brcm&quot;&gt;brcmfmac43430-sdio.txt&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;wpa-supplicant&lt;/li&gt;
  &lt;li&gt;wireless-tools&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;
&lt;p&gt;Download and place the &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac43430-sdio.bin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;brcmfmac43430-sdio.txt&lt;/code&gt; inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/firmware/brcm&lt;/code&gt; folder.
If the file above doesn’t make your wifi to work get it directly from the Mainstream linux: &lt;a href=&quot;git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next we’ll modify &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/network/interfaces&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo nano /etc/network/interfaces
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And place this following lines:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allow-hotplug wlan0
iface wlan0 inet dhcp
wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For this setup my wifi interfaces id &lt;code class=&quot;highlighter-rouge&quot;&gt;wlan0&lt;/code&gt;… yours might be named differently so replace it
that matches yours.
You can set your wifi to static…just browse the references at the bottom of this page..&lt;/p&gt;

&lt;p&gt;Then we’ll configure &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code&gt; … so create/edit the file &lt;code class=&quot;highlighter-rouge&quot;&gt;wpa_supplicant.conf&lt;/code&gt; and place this lines:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;network={
    ssid=&quot;NetworkEssid&quot;
    scan_ssid=1 # only needed if your access point uses a hidden ssid
    proto=RSN
    key_mgmt=WPA-PSK
    psk=&quot;NetworkPassword&quot;
	pairwise=CCMP
	auth_alg=OPEN
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Reboot and verify that wifi is now working and connected to the network.
or you could try this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ifconfig wlan0 down
$ sudo ifconfig wlan0 up
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;reference&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/RPi-Distro/firmware-nonfree/tree/master/brcm80211/brcm&quot;&gt;https://github.com/RPi-Distro/firmware-nonfree/tree/master/brcm80211/brcm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/WifiDocs/WPAHowTo&quot;&gt;https://help.ubuntu.com/community/WifiDocs/WPAHowTo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf&quot;&gt;https://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">To make the Raspberry pi 3 Wifi to work…we need to get or have atleast 2 files. But first we must create a folder inside the /lib/firmware/ and name it brcm. And in that folder we’ll put brcmfmac43430-sdio.bin and brcmfmac43430-sdio.txt. Prerequisite: brcmfmac43430-sdio.bin brcmfmac43430-sdio.txt wpa-supplicant wireless-tools</summary></entry><entry><title type="html">Using Ubuntu-base arm64 rootfs for Raspberry Pi 3</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/using-ubuntu-base.html" rel="alternate" type="text/html" title="Using Ubuntu-base arm64 rootfs for Raspberry Pi 3" /><published>2017-05-16T00:00:00+08:00</published><updated>2017-05-16T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/using-ubuntu-base</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/using-ubuntu-base.html">&lt;p&gt;Following my previous &lt;a href=&quot;rpi3-64bit-kernel-and-Uboot-booting-up&quot;&gt;post&lt;/a&gt;, we now can now boot our kernel thru U-boot. 
Now were going to create a filesystem base from arm64 ubuntu base rootfs.&lt;/p&gt;

&lt;p&gt;Create a folder were we will extract the Ubuntu base &lt;a href=&quot;http://cdimage.ubuntu.com/ubuntu-base/releases/16.04.2/release/ubuntu-base-16.04.2-base-arm64.tar.gz&quot;&gt;&lt;b&gt;rootfs&lt;/b&gt;&lt;/a&gt;, and tar to extract.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir rootfs
$ cd rootfs/
$ sudo tar xzvf ubuntu-base-16.04.2-base-arm64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;!--more--&gt;
&lt;p&gt;Install the kernel module and firmware into the rootfs folder.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_install INSTALL_MOD_PATH={directory}/rootfs/
$ sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- firmware_install INSTALL_FW_PATH={directory}rootfs/lib/firmware/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Check that it was installed correctly.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls rootfs/lib/modules/4.11~

	build               modules.builtin        modules.devname      modules.symbols.bin
	kernel              modules.builtin.bin    modules.order        source
	modules.alias       modules.dep            modules.softdep
	modules.alias.bin   modules.dep.bin        modules.symbols
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Well use &lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt; to further setup our filesystem.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo cp -av /usr/bin/qemu-aarch64-static {directory}/rootfs/usr/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;or-use-rsync-rsync--azvh-source-destination&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Or use rsync: rsync -azvh source destination&lt;/h6&gt;

&lt;h6 id=&quot;note&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Note:&lt;/h6&gt;
&lt;h6 id=&quot;-usrbinqemu-arm-static-is-for-32-bit-armhf-architecture&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;*	/usr/bin/&lt;b&gt;qemu-arm-static&lt;/b&gt; is for 32-bit armhf architecture&lt;/h6&gt;
&lt;h6 id=&quot;-usrbinqemu-aarch64-static-is-for-64-bit-arm64-architecture&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;*	/usr/bin/&lt;b&gt;qemu-aarch64-static&lt;/b&gt; is for 64-bit arm64 architecture&lt;/h6&gt;

&lt;p&gt;Then we need to copy &lt;code class=&quot;highlighter-rouge&quot;&gt;resolv.conf&lt;/code&gt; from our host machine for internet connection to &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs/etc/&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo cp -av /run/resolvconf/resolv.conf rootfs/etc/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Enter chroot environment:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo chroot {directory}rootfs/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now that you’re in the chroot environment, we can now add an admin user with sudo permission.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ useradd -G sudo -m -s /bin/bash pi3
$ echo pi3:pi3 | chpasswd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;note-the-format-input-line-of-chpasswd-is-user_namepassword&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Note: The format input line of chpasswd is: user_name:password.&lt;/h6&gt;

&lt;p&gt;You can setup your &lt;code class=&quot;highlighter-rouge&quot;&gt;hostname&lt;/code&gt; here for your target device or in the kernel configuration making sure that the hostname is empty.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo U-Base_min &amp;gt; /etc/hostname
$ echo 127.0.0.1 localhost &amp;gt; /etc/hosts
$ echo 127.0.1.1 U-Base_min &amp;gt;&amp;gt; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Fetch the latest package lists from server then upgrade.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get update
$ apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then install these first:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install dialog perl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We need those installed first to correct some error messages abot locale:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ locale-gen &quot;en_US.UTF-8&quot;
	Generating locales...
  		en_US.UTF-8... done
	Generation complete.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Install minimal packages:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt-get install sudo ifupdown net-tools ethtool udev wireless-tools iputils-ping resolvconf wget apt-utils wpasupplicant initramfs-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Create a Ramdisk(optional).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkinitramfs -o /boot/initrd.img /lib/modules/4.11~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When everything you want to setup has been done, exit chroot:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To reduce the rootfs/ size we can remove some unwanted files.
Create a file &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/dpkg/dpkg.cfg.d/01_nodoc&lt;/code&gt; which specifies the desired filters. Example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;path-exclude /usr/share/doc/*
# we need to keep copyright files for legal reasons
path-include /usr/share/doc/*/copyright
path-exclude /usr/share/man/*
path-exclude /usr/share/groff/*
path-exclude /usr/share/info/*
# lintian stuff is small, but really unnecessary
path-exclude /usr/share/lintian/*
path-exclude /usr/share/linda/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then you can manually remove any documentation already installed:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo find rootfs/usr/share/doc -depth -type f ! -name copyright|xargs rm || true
$ sudo find rootfs/usr/share/doc -empty|xargs rmdir || true
$ sudo rm -rf rootfs/usr/share/man/* rootfs/usr/share/groff/* rootfs/usr/share/info/*
$ sudo rm -rf rootfs/usr/share/lintian/* rootfs/usr/share/linda/* rootfs/var/cache/man/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then copy the &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs/&lt;/code&gt; content to the 2nd partition of your µSD car. Or you could make an image file with several partition on it. This will create a 2gb empty img file:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo dd if=/dev/zero of=myimage.img bs=1024 count=2M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then partition it using &lt;code class=&quot;highlighter-rouge&quot;&gt;fdisk&lt;/code&gt; in my case:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo fdisk myimage.img
	Result:
	| Device     | Boot | Start 	| End	  | Sectors |
	|:-----------|:-----|:----------|:--------|:--------|
	| myimage1   |      | 2048  	| 1026047 | 1024000 | Fat
	| myimage2   |      | 1026048 	| 4194303 | 3168256 | Linux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Display the name of the assigned loop device:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo losetup --find --show myimage.img
	
	/dev/loop0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;fdisk&lt;/code&gt; to identify our image file partitions assinged loop&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo fdisk /dev/loop0

	Device:
		/dev/loop1
		/dev/loop2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then, to assign a loopback device: and format it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo losetup /dev/loop1 myimage.img 
$ sudo losetup /dev/loop2 myimage.img
$ sudo mkfs.vfat /dev/loop1
$ sudo mkfs.ext4 /dev/loop2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;mkfsvfat--n-partition-name-devloop1&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;mkfs.vfat -n &lt;code class=&quot;highlighter-rouge&quot;&gt;partition name&lt;/code&gt; /dev/loop1&lt;/h6&gt;

&lt;p&gt;Mount and Copy those necessary files that we need to their respected partition.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mount /dev/loop1 /mnt/boot
$ sudo mount /dev/loop2 /mnt/rootfs

	then umount and detach:
$ sudo umount /dev/loop1
$ sudo umount /dev/loop2
$ sudo losetup --detach /dev/loop1
$ sudo losetup --detach /dev/loop2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can now burn that myimage.img to yor µsd card.
Now boot it up and you should now be able to login.&lt;/p&gt;

&lt;p&gt;Net post will be about setting up the wifi.&lt;/p&gt;

&lt;h5 id=&quot;reference&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.khadas.com/social/BuildUbuntuRootfsViaUbuntuBase/&quot;&gt;http://docs.khadas.com/social/BuildUbuntuRootfsViaUbuntuBase/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gnu-linux.org/building-ubuntu-rootfs-for-arm.html&quot;&gt;https://gnu-linux.org/building-ubuntu-rootfs-for-arm.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html&quot;&gt;http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">Following my previous post, we now can now boot our kernel thru U-boot. Now were going to create a filesystem base from arm64 ubuntu base rootfs. Create a folder were we will extract the Ubuntu base rootfs, and tar to extract. $ mkdir rootfs $ cd rootfs/ $ sudo tar xzvf ubuntu-base-16.04.2-base-arm64.tar.gz</summary></entry><entry><title type="html">Raspberry Pi 3 64bit kernel and U-boot booting up</title><link href="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/rpi3-64bit-kernel-and-Uboot-booting-up.html" rel="alternate" type="text/html" title="Raspberry Pi 3 64bit kernel and U-boot booting up" /><published>2017-05-16T00:00:00+08:00</published><updated>2017-05-16T00:00:00+08:00</updated><id>http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/rpi3-64bit-kernel-and-Uboot-booting-up</id><content type="html" xml:base="http://a-delacruz.github.io/a-DelaCruz.github.io/ubuntu/2017/05/16/rpi3-64bit-kernel-and-Uboot-booting-up.html">&lt;p&gt;Updated, Organized and corrected some typos:&lt;/p&gt;

&lt;h4 id=&quot;cross-build-prerequisite&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Cross-build prerequisite:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc-arch64-linux-gnu    g++-5                  ncurses-dev
make                    git                    bc          
u-boot-tools            device-tree-compiler   pkg-config-aarch64-linux-gnu
libncurses5-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;!--more--&gt;
&lt;p&gt;Assuming there is already a Cross-build environment: Built on Ubuntu Server 16.04.02&lt;/p&gt;

&lt;h4 id=&quot;prerequisites&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Prerequisites:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Ubuntu Base &lt;a href=&quot;http://cdimage.ubuntu.com/ubuntu-base/releases/16.04.2/release/ubuntu-base-16.04.2-base-arm64.tar.gz&quot;&gt;Rootfs&lt;/a&gt; (install additional package using apt-get)&lt;/li&gt;
  &lt;li&gt;Raspberry pi &lt;a href=&quot;https://github.com/raspberrypi/linux.git&quot;&gt;kernel&lt;/a&gt; (Have not tried using Upstream kernel)&lt;/li&gt;
  &lt;li&gt;Raspberry pi &lt;a href=&quot;https://github.com/raspberrypi/firmware/tree/master/boot&quot;&gt;firmware&lt;/a&gt;(bootcode.bin, start.elf, fixup.dat as this are the min. files to boot)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.denx.de/wiki/U-Boot/WebHome&quot;&gt;U-boot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;µsd-card-assuming-you-already-know-how-to-partition-it&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;µSD card: &lt;code class=&quot;highlighter-rouge&quot;&gt;(assuming you already know how to partition it)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Your µSD card(fat partition 1) should contain the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/boot
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;note-boot-sub-folder-will-contain-our-u-boot-file-kernel-and-initrd-image-file&quot;&gt;&lt;a href=&quot;#header-6&quot;&gt;&lt;/a&gt;Note: &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; sub-folder will contain our U-Boot file, Kernel and Initrd image file.&lt;/h6&gt;

&lt;p&gt;For the &lt;code class=&quot;highlighter-rouge&quot;&gt;config.txt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cmdline.txt&lt;/code&gt;, we have to create them and include this lines.&lt;/p&gt;

&lt;h5 id=&quot;configtxt&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;config.txt:&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arm_control=0x200
force_turboo=1
enable_uart=1
device_tree_address=0x100
device_tree_end=0x8000
kernel=boot/kernel8.img
dtparam=i2c_arm=on
dtparam=spi=on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;cmdlinetxt&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;cmdline.txt:&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;u-boot&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;U-Boot:&lt;/h4&gt;
&lt;p&gt;Get the source code by cloning the U-Boot git repository or download the tar file.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone depth 1 branch v2017.03 single-branch git://git.denx.de/u-boot.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;or download:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ftp://ftp.denx.de/pub/u-boot/u-boot-2017.03.tar.bz2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then configure and build u-boot. For 64-bit use &lt;code class=&quot;highlighter-rouge&quot;&gt;rpi_3_defconfig&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd u-boot/
$ sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- rpi_3_defconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then compile it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To change output directory use &lt;code class=&quot;highlighter-rouge&quot;&gt;O=Output path/&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=Output path/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After it has been built. Locate &lt;code class=&quot;highlighter-rouge&quot;&gt;u-boot.bin&lt;/code&gt; in your output_path as this is the file we need. 
Copy it to your µSD card inside &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot folder&lt;/code&gt; and rename it to &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel8.img&lt;/code&gt; or keep its name as is in config.txt. 
Boot it up to confirm that its working.&lt;/p&gt;

&lt;h4 id=&quot;kernel&quot;&gt;&lt;a href=&quot;#header-4&quot;&gt;&lt;/a&gt;Kernel:&lt;/h4&gt;
&lt;p&gt;Get the kernel source code at the official Raspberry pi git repository.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone depth 1 branch v2017.03 single-branch https://github.com/raspberrypi/linux.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Use &lt;code class=&quot;highlighter-rouge&quot;&gt;bcmrpi3_defconfig&lt;/code&gt; for kernel config. 
You can further configure it according to your needs. But for now, its fine to leave it be.
You can also change the output directory using: &lt;code class=&quot;highlighter-rouge&quot;&gt;O=Output_path/&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd linux
$ sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcmrpi3_defconfig
$ sudo make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Locate &lt;code class=&quot;highlighter-rouge&quot;&gt;Image&lt;/code&gt; (no need to convert for U-Boot use it as it is for 64bit) file at your output_path/ &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/arm64/boot/&lt;/code&gt; 
and the &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2710-rpi-3-b.dtb&lt;/code&gt; at &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/arm/boot/dts/&lt;/code&gt;. I encounter problem using 
&lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2837-rpi-3-b.dtb&lt;/code&gt;. So for now use &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2710-rpi-3-b.dtb&lt;/code&gt; instead. 
Copy the &lt;code class=&quot;highlighter-rouge&quot;&gt;Image&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot folder&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bcm2710-rpi-3-b.dtb&lt;/code&gt; in the upper most directory of your µSD card.
It should look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/boot/Image
/boot/kernel8.img
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At this point, you can test it if it will boot the kernel but we need to have a boot script that U-Boot needs. 
Were using the boot.script from this file: &lt;a href=&quot;https://www.finnie.org/software/raspberrypi/ubuntu-rpi3/20160517-raspi3-arm64-firmware-kernel.tar.xz&quot;&gt;&lt;b&gt;20160517-raspi3-arm64-firmware-kernel.tar.xz&lt;/b&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Modify and create the &lt;code class=&quot;highlighter-rouge&quot;&gt;boot.scr&lt;/code&gt; from it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkimage -A arm64 -O linux -T script -d /path/to/boot.script /path/where/you/want/to/save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boot.script&lt;/code&gt; should look like this: and place it inside hte &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; folder.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fdt addr 0x100
fdt get value bootargs /chosen bootargs
setenv kernel_addr_r 0x01000000
setenv ramdisk_addr_r 0x02100000
fatload mmc 0:1 ${kernel_addr_r} boot/Image
fatload mmc 0:1 ${ramdisk_addr_r} boot/initrd.img
setenv initrdsize $filesize
fatload mmc 0:1 ${fdt_addr_r} bcm2710-rpi-3-b.dtb
booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Since we dont have a Ramdisk yet, comment that line and replace &lt;code class=&quot;highlighter-rouge&quot;&gt;${ramdisk_addr_r}:${initrdsize}&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;.
Or copy the &lt;code class=&quot;highlighter-rouge&quot;&gt;initrd.img&lt;/code&gt; to use it temporarily.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/boot/Image
/boot/boot.scr
/boot/kernel8.img
/boot/initrd.img
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can now then verify at this point that our kernel boot as well and will stop at some point 
since we still do not have a filesystem.&lt;/p&gt;

&lt;p&gt;Next post will be about on how to make a filesystem base on Ubuntu Base.&lt;/p&gt;

&lt;h5 id=&quot;reference&quot;&gt;&lt;a href=&quot;#header-5&quot;&gt;&lt;/a&gt;Reference:&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.ubuntu.com/ARM/RaspberryPi/RaspberryPi3&quot;&gt;https://wiki.ubuntu.com/ARM/RaspberryPi/RaspberryPi3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.ubuntu.com/Base&quot;&gt;https://wiki.ubuntu.com/Base&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.raspberrypi.org/documentation/linux/kernel/building.md&quot;&gt;https://www.raspberrypi.org/documentation/linux/kernel/building.md&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kernelnomicon.org/?p=682&quot;&gt;https://kernelnomicon.org/?p=682&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name></name></author><category term="ubuntu" /><summary type="html">Updated, Organized and corrected some typos: Cross-build prerequisite: gcc-arch64-linux-gnu g++-5 ncurses-dev make git bc u-boot-tools device-tree-compiler pkg-config-aarch64-linux-gnu libncurses5-dev</summary></entry></feed>