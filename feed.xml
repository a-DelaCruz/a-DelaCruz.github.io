<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://0.0.0.0:5000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:5000/" rel="alternate" type="text/html" /><updated>2018-10-08T11:25:42+08:00</updated><id>http://0.0.0.0:5000/feed.xml</id><title type="html">My Personal Notes</title><subtitle>Raspberry Pi 3 64-Bit kernel and arm64 rootfs</subtitle><entry><title type="html">QT 5.11.2 on a Raspberry Pi 3</title><link href="http://0.0.0.0:5000/topics/QT-on-pi.html" rel="alternate" type="text/html" title="QT 5.11.2 on a Raspberry Pi 3" /><published>2018-09-25T00:00:00+08:00</published><updated>2018-09-25T00:00:00+08:00</updated><id>http://0.0.0.0:5000/topics/QT-on-pi</id><content type="html" xml:base="http://0.0.0.0:5000/topics/QT-on-pi.html">***To-Do

Since i need to make a GUI for my Raspberry Pi projects... I want something that 'Does' not require any desktop environment.
And as a start should be c++. I've research the net and found 3 promising tools and one of them is QT.

At first what i really want is a web based gui and planned to use .Net Core but decided to build a gui using a touch screen display instead which lead me to QT. I've already managed to build and create a gui using QT 5.10.1 and a lower priority to make a post about it. And now i have and sharing it with you.

You have the option of natively compiling or which i prefer is to cross-build. Which ever you choose is fine and the process is almost the same.
We're going to use QT Creator for the GUI and cross-build the required packages for are usage. You also have the option to either build QT Creator from source or not.

#### Cross-Build Prerequisites
For building QT from source... these files and packages are needed.

{% highlight terminal linenos %}
build-essential
make
python
git

libqt5gui5
libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0
{% endhighlight %}







##### Reference
[RaspberryPi2EGLFS](https://wiki.qt.io/RaspberryPi2EGLFS)</content><author><name></name></author><category term="Topics" /><summary type="html">***To-Do</summary></entry><entry><title type="html">.Net Core on Raspberry Pi 3</title><link href="http://0.0.0.0:5000/ubuntu/docker.html" rel="alternate" type="text/html" title=".Net Core on Raspberry Pi 3" /><published>2018-01-18T00:00:00+08:00</published><updated>2018-01-18T00:00:00+08:00</updated><id>http://0.0.0.0:5000/ubuntu/docker</id><content type="html" xml:base="http://0.0.0.0:5000/ubuntu/docker.html">I thought i could get away from using a debian-based Docker image for .Net Core... *sigh...

For now an `Alpine-based` Docker image is available for `.NET Core` on amd64. But the runtime-deps can also be installed to an `arm32v6 architecture` which Alpine-Linux support so the possibility is almost there.

To use the latest build preview get it from here: &lt;a href=&quot;https://github.com/dotnet/cli&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;.Net Core SDK&lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;&lt;/a&gt;

{% include callouts/callout.html content=&quot;I'm using `Ubuntu 17.10 on my RPi3` and as of typing this... there's no v17.12 available Docker so i use one from the xenial.&quot; type=&quot;note&quot; %}

{% highlight terminal linenos %}
wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/arm64/docker-ce_17.12.0~ce-0~ubuntu_arm64.deb

sudo dpkg -i docker-ce_17.12.0~ce-0~ubuntu_arm64.deb
{% endhighlight %}

#### Docker-ce deps:

{% highlight terminal linenos %}
sudo apt-get install libltdl7
{% endhighlight %}

{% include callouts/callout.html content=&quot;Run below cmd if there's still some missing dependencies&quot; type=&quot;note&quot; %}

{% highlight terminal linenos %}
sudo apt-get install -f install
{% endhighlight %}

Then just run `docker -v` and add your user to docker group.

Get the Dockerfile where we will create our image with the latest .Net Core.

{% highlight terminal linenos %}
wget https://raw.githubusercontent.com/dotnet/dotnet-docker-nightly/master/2.1/runtime/stretch/arm32v7/Dockerfile
{% endhighlight %}

Then let's build it.

{% highlight terminal linenos %}
docker build -t dotnet .
{% endhighlight %}

For a test app... let's get one...

{% highlight terminal linenos %}
git clone https://github.com/dotnet/dotnet-docker-samples/
{% endhighlight %}

We'll use `linux-arm` as the target runtime for arm32.

{% highlight terminal linenos %}
cd dotnetapp-selfcontained
dotnet publish -c release -r linux-arm -o selfcontained-linux-arm
{% endhighlight %}

{% include callouts/callout.html content=&quot;`dotnet run` while your inside `dotnetapp-selfcontained` to see the App in action.&quot; type=&quot;note&quot; %}

{% include callouts/callout.html content=&quot;I use Windows to Build this test app then use `winSCP` to transfer the `selfcontained-linux-arm` folder on to the Raspberry Pi 3&quot; type=&quot;note&quot; %}

{% highlight terminal linenos %}
docker run -it --rm -v /home/pi3:/home/share dotnet
{% endhighlight %}

And to execute the test app... run this command inside the docker environment.

{% highlight terminal linenos %}
dotnet /home/share/selfcontained-linux-arm/dotnetapp.dll
{% endhighlight %}
&lt;img src=&quot;/assets/images/ubuntu/robot.png&quot; class=&quot;responsive-img&quot;/&gt;

&lt;br /&gt;
&lt;div class=&quot;mdc-tab-bar&quot; role=&quot;tablist&quot;&gt;
  &lt;div class=&quot;mdc-tab-scroller&quot;&gt;
    &lt;div class=&quot;mdc-tab-scroller__scroll-area mdc-tab-scroller__scroll-area--scroll&quot; style=&quot;margin-bottom: 0px;&quot;&gt;
      &lt;div class=&quot;mdc-tab-scroller__scroll-content&quot;&gt;
        &lt;button class=&quot;tab-item mdc-tab mdc-tab--active&quot; role=&quot;tab&quot; aria-selected=&quot;true&quot; tabindex=&quot;0&quot; onclick=&quot;openGPIO('console-gpio')&quot;&gt;
          &lt;span class=&quot;mdc-tab__content&quot;&gt;
            &lt;span class=&quot;mdc-tab__text-label&quot;&gt;Console GPIO&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab-indicator mdc-tab-indicator--active&quot;&gt;
            &lt;span class=&quot;mdc-tab-indicator__content mdc-tab-indicator__content--underline&quot;&gt;&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab__ripple mdc-ripple-upgraded&quot;&gt;&lt;/span&gt;
        &lt;/button&gt;
        &lt;button class=&quot;tab-item mdc-tab&quot; role=&quot;tab&quot; aria-selected=&quot;false&quot; tabindex=&quot;-1&quot; onclick=&quot;openGPIO('webapp-gpio')&quot;&gt;
          &lt;span class=&quot;mdc-tab__content&quot;&gt;
            &lt;span class=&quot;mdc-tab__text-label&quot;&gt;WebApp GPIO&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab-indicator&quot;&gt;
            &lt;span class=&quot;mdc-tab-indicator__content mdc-tab-indicator__content--underline&quot;&gt;&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab__ripple mdc-ripple-upgraded&quot;&gt;&lt;/span&gt;
        &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;!-- Console GPIO --&gt;
&lt;div id=&quot;console-gpio&quot;&gt;
&lt;br /&gt;
  I wan't to try .Net Core on linux-arm64... but unfortunately, there's no available yet except Win-arm64 and linux-arm32. For this one we'll use a bcm2835 library but later a C# version of this library i had which is on-hold until today.

  &lt;h4&gt;Prerequisites&lt;/h4&gt;
  &lt;a href=&quot;http://www.airspayce.com/mikem/bcm2835/bcm2835-1.55.tar.gz&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;bcm2835 library&lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;&lt;/a&gt;
  {% include callouts/callout.html content=&quot;Be sure `gcc make` are installed&quot; type=&quot;note&quot; %}

    Extract &lt;code&gt;bcm2835-1.55.tar.gz&lt;/code&gt; anywhere you like, because where going to remove it once we have `libbcm2835.so`.
    
{% highlight terminal linenos %}
tar zxvf bcm2835-1.55.tar.gz
cd bcm2835-1.52/src
gcc -fPIC -c bcm2835.c
gcc -shared bcm2835.o -o libbcm2835.so
{% endhighlight %}

  You can now remove the &lt;code&gt;bcm2835-1.55 folder&lt;/code&gt; and be sure to put &lt;code&gt;libbcm2835.so&lt;/code&gt; inside &lt;code&gt;/lib/aarch-~&lt;/code&gt; folder.

  We'll create a simple console app using these command &lt;code&gt;dotnet new console -o testapp&lt;/code&gt;.
  
  Then modify &lt;code&gt;Program.cs&lt;/code&gt; with these codes. What it does is we use &lt;code&gt;libbcm2835.so&lt;/code&gt; C internal commands into our C# app using PInvoke.

  Take note of the &lt;code&gt;PIN Numbering&lt;/code&gt;: bcm2835 library use physical numbering so &lt;code&gt;RPI_GPIO_P1_07&lt;/code&gt; is equal to GPIO4 of our RPi3.
  &lt;img src=&quot;/assets/images/ubuntu/Raspberry-Pi-3-GPIO-Layout-Model-B.jpg&quot; class=&quot;responsive-img&quot;/&gt;

{% highlight cs %}
// Program.cs

using System;
using System.Runtime.InteropServices;

namespace testapp
{
    class Program
    {
        private static uint HIGH = 0x1;
        private static uint LOW  = 0x0;
        private static byte RPI_GPIO_P1_07 = 4;
        private static byte BCM2835_GPIO_FSEL_OUTP = 0x01;

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern int bcm2835_init();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_close();

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_delay(uint millis);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_fsel(byte pin, byte mode);

        [DllImport(&quot;libbcm2835.so&quot;)]
        public static extern void bcm2835_gpio_write(byte pin, uint on);

        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Hello World!&quot;);

            if (bcm2835_init() == 1)
            {
                
                    bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP);
                    
                    // Blink
                    while(true)
                    {
                        // Turn it on
                        bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH);
                        // wait
                        bcm2835_delay(500);
                        // turn it off
                        bcm2835_gpio_write(RPI_GPIO_P1_07, LOW);
                        // wait 
                        bcm2835_delay(500);
                    }
                
            }
            bcm2835_close();
        }
    }
}
{% endhighlight %}

Then issue the command while inside the &lt;code&gt;testapp folder&lt;/code&gt;. And copy &lt;code&gt;testapp-linux-arm&lt;/code&gt; folder to your Raspberry Pi 3.

{% highlight terminal linenos %}
dotnet publish -c release -r linux-arm -o testapp-linux-arm
{% endhighlight %}

Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. &lt;code&gt;Please be careful and you should know how to properly hook up our test led to avoid breaking your RPi3&lt;/code&gt;.

In RPi3, let us run the docker image then test our testapp on it.
{% highlight terminal linenos %}
docker run -it --privileged --rm -v /home/pi3:/home/share dotnet
{% endhighlight %}
{% include callouts/callout.html content=&quot;`--privileged` - To give docker access rights to `/dev/gpiomem`. `--rm` - the container is removed when it exits or when the daemon exits&quot; type=&quot;note&quot; %}

Make sure that you have &lt;code&gt;libbcm2835.so&lt;/code&gt; inside the &lt;code&gt;/lib/aarch64-~&lt;/code&gt; folder or it will complain about running it in SDK.

Then run our testapp like so...
{% highlight terminal linenos %}
dotnet /home/share/testapp-linux-arm/testapp.dll
{% endhighlight %}

Your led should be blinking right now.... 
&lt;/div&gt;


&lt;!-- WebApp GPIO --&gt;
&lt;div id=&quot;webapp-gpio&quot;&gt;
&lt;br /&gt;
  For revision...
&lt;/div&gt;


&lt;!-- for tabs --&gt;
&lt;script&gt;
  var demoItems = document.querySelectorAll('.tab-item');
  var tabItems = document.getElementsByClassName('.tab-item');
  
  [].forEach.call(demoItems, function (demoItem) {
    var activeIndicator = demoItem.querySelector('.mdc-tab-indicator');
  
    demoItem.addEventListener('click', function() {
      console.log(&quot;Clicked Test &quot; );
      [].forEach.call(demoItems, function (demoItem) {
        var indicatorEl = demoItem.querySelector('.mdc-tab-indicator');
        indicatorEl.classList.remove('mdc-tab-indicator--active');
      });
      activeIndicator.classList.toggle('mdc-tab-indicator--active');

      [].forEach.call(demoItems, function (demoItem) {
        demoItem.classList.remove('mdc-tab--active');
      });
      demoItem.classList.toggle('mdc-tab--active');

      

    });

  });

document.getElementById(&quot;webapp-gpio&quot;).style.display = &quot;none&quot;;

  function openGPIO(AppName) {
    document.getElementById(&quot;console-gpio&quot;).style.display = &quot;none&quot;;
    document.getElementById(&quot;webapp-gpio&quot;).style.display = &quot;none&quot;;
    document.getElementById(AppName).style.display = &quot;block&quot;;
  }
&lt;/script&gt;</content><author><name></name></author><category term="Ubuntu" /><summary type="html">I thought i could get away from using a debian-based Docker image for .Net Core… *sigh… For now an Alpine-based Docker image is available for .NET Core on amd64. But the runtime-deps can also be installed to an arm32v6 architecture which Alpine-Linux support so the possibility is almost there. To use the latest build preview get it from here: .Net Core SDKfile_download I’m using Ubuntu 17.10 on my RPi3 and as of typing this… there’s no v17.12 available Docker so i use one from the xenial. 1 2 3 wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/arm64/docker-ce_17.12.0~ce-0~ubuntu_arm64.deb sudo dpkg -i docker-ce_17.12.0~ce-0~ubuntu_arm64.deb Docker-ce deps: 1 sudo apt-get install libltdl7 Run below cmd if there’s still some missing dependencies 1 sudo apt-get install -f install Then just run docker -v and add your user to docker group. Get the Dockerfile where we will create our image with the latest .Net Core. 1 wget https://raw.githubusercontent.com/dotnet/dotnet-docker-nightly/master/2.1/runtime/stretch/arm32v7/Dockerfile Then let’s build it. 1 docker build -t dotnet . For a test app… let’s get one… 1 git clone https://github.com/dotnet/dotnet-docker-samples/ We’ll use linux-arm as the target runtime for arm32. 1 2 cd dotnetapp-selfcontained dotnet publish -c release -r linux-arm -o selfcontained-linux-arm dotnet run while your inside dotnetapp-selfcontained to see the App in action. I use Windows to Build this test app then use winSCP to transfer the selfcontained-linux-arm folder on to the Raspberry Pi 3 1 docker run -it --rm -v /home/pi3:/home/share dotnet And to execute the test app… run this command inside the docker environment. 1 dotnet /home/share/selfcontained-linux-arm/dotnetapp.dll Console GPIO WebApp GPIO I wan't to try .Net Core on linux-arm64... but unfortunately, there's no available yet except Win-arm64 and linux-arm32. For this one we'll use a bcm2835 library but later a C# version of this library i had which is on-hold until today. Prerequisites bcm2835 libraryfile_download Be sure gcc make are installed Extract bcm2835-1.55.tar.gz anywhere you like, because where going to remove it once we have `libbcm2835.so`. 1 2 3 4 tar zxvf bcm2835-1.55.tar.gz cd bcm2835-1.52/src gcc -fPIC -c bcm2835.c gcc -shared bcm2835.o -o libbcm2835.so You can now remove the bcm2835-1.55 folder and be sure to put libbcm2835.so inside /lib/aarch-~ folder. We'll create a simple console app using these command dotnet new console -o testapp. Then modify Program.cs with these codes. What it does is we use libbcm2835.so C internal commands into our C# app using PInvoke. Take note of the PIN Numbering: bcm2835 library use physical numbering so RPI_GPIO_P1_07 is equal to GPIO4 of our RPi3. // Program.cs using System; using System.Runtime.InteropServices; namespace testapp { class Program { private static uint HIGH = 0x1; private static uint LOW = 0x0; private static byte RPI_GPIO_P1_07 = 4; private static byte BCM2835_GPIO_FSEL_OUTP = 0x01; [DllImport(&quot;libbcm2835.so&quot;)] public static extern int bcm2835_init(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_close(); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_delay(uint millis); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_fsel(byte pin, byte mode); [DllImport(&quot;libbcm2835.so&quot;)] public static extern void bcm2835_gpio_write(byte pin, uint on); static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); if (bcm2835_init() == 1) { bcm2835_gpio_fsel(RPI_GPIO_P1_07, BCM2835_GPIO_FSEL_OUTP); // Blink while(true) { // Turn it on bcm2835_gpio_write(RPI_GPIO_P1_07, HIGH); // wait bcm2835_delay(500); // turn it off bcm2835_gpio_write(RPI_GPIO_P1_07, LOW); // wait bcm2835_delay(500); } } bcm2835_close(); } } } Then issue the command while inside the testapp folder. And copy testapp-linux-arm folder to your Raspberry Pi 3. 1 dotnet publish -c release -r linux-arm -o testapp-linux-arm Assuming you know how to and already hook up our test circuit: a led attach to our GPIO4 or rather PIN7 on the RPi3 physical Pin header. Please be careful and you should know how to properly hook up our test led to avoid breaking your RPi3. In RPi3, let us run the docker image then test our testapp on it. 1 docker run -it --privileged --rm -v /home/pi3:/home/share dotnet --privileged - To give docker access rights to /dev/gpiomem. --rm - the container is removed when it exits or when the daemon exits Make sure that you have libbcm2835.so inside the /lib/aarch64-~ folder or it will complain about running it in SDK. Then run our testapp like so... 1 dotnet /home/share/testapp-linux-arm/testapp.dll Your led should be blinking right now.... For revision...</summary></entry><entry><title type="html">Raspberry Pi 3 64-bit kernel</title><link href="http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-kernel.html" rel="alternate" type="text/html" title="Raspberry Pi 3 64-bit kernel" /><published>2017-11-03T00:00:00+08:00</published><updated>2017-11-03T00:00:00+08:00</updated><id>http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-kernel</id><content type="html" xml:base="http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-kernel.html">#### Cross-Build Prerequisites
For building our own 64-bit kernel fom scratch using the Raspberry Pi Foundation repository, a couple of dependencies are needed. You may however use the mainline kernel though i haven't tried to use it.
&lt;br /&gt;

{% highlight terminal linenos %}
//make sure these are installed:

bc git make device-tree-compiler gcc-aarch64-linux-gnu build-essential u-boot-tools ncurses-dev qemu-user-static pkg-config
{% endhighlight %}

we also need:
&lt;a href=&quot;https://github.com/raspberrypi/linux.git&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;
  kernel RPi Repo
  &lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/raspberrypi/firmware/tree/master/boot&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;
  RPi firmware
  &lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;
&lt;/a&gt;

{% include callouts/callout.html content=&quot;`bootcode.bin`, `start.elf`, `fixup.dat` as this are the min. files to boot. The rest of `star.* and fixup.*` files for graphical desktop&quot; type=&quot;note&quot; %}

#### Compile the Kernel
Use any Linux machine of your choice or Windows 10's Bash to compile the kernel is all up to you. 
To get the kernel we need, we can either download it as a compressed file using the links above or we could use `git` to make it simpler.

{% highlight terminal linenos %}
git clone --depth 1 --branch rpi-4.14.y https://github.com/raspberrypi/linux.git rpi-4.14.70
{% endhighlight %}

{% highlight terminal linenos %}
mkdir bo_4.14
sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14 bcmrpi3_defconfig
sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14 -j4
{% endhighlight %}

{% include callouts/callout.html content=&quot;`bcmrpi3_defconfig` - arm64 config. `-C source folder/`. `O=$HOME/output-folder` - Output directory. `-jX` - build the kernel in a multithreaded way where: `X = [Num of core x 2]`&quot; type=&quot;note&quot; %}

{% include callouts/callout.html content=&quot;`Image` file @ `$HOME/bo_4.14/arch/arm64/boot/` &lt;br/&gt;`bcm2710-rpi-3-b.dtb` @ `$HOME/bo_4.14/arch/arm64/boot/dts/broadcom/`&quot; type=&quot;note&quot; %}

####  Create config.txt and cmdline.txt
For the `config.txt` and `cmdline.txt`, we have to create those files and add these lines.

{% highlight terminal linenos %}
//config.txt

# Serial console output!
enable_uart=1

# 64bit-mode
arm_control=0x200

kernel=kernel8.img

device_tree_address=0x100
device_tree_end=0x8000

# For i2c &amp; spi
dtparam=i2c_arm=on
dtparam=spi=on
{% endhighlight %}

{% highlight terminal linenos %}
//cmd.txt

dwc_otg.lpm_enable=0 console=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait
{% endhighlight %}

####  Transfer the necessary files to the MicroSD
Since we dont have a Ramdisk yet, we are using this [20160517-raspi3-arm64-firmware-kernel.tar.xz](https://www.finnie.org/software/raspberrypi/ubuntu-rpi3/) for now and we'll create a new one on our own.

{% include callouts/callout.html content=&quot;To Do - i have to verify if this still works&quot; type=&quot;note&quot; %}

Rename the `Image` file we had earlier to `kernel8.img`. `start.elf` file knows `kernel8.img` file is a kernel to load.
{% highlight terminal linenos %}
//MicroSD card should now contain these files below

bootcode.bin
start.elf
fixup.dat
config.txt
cmdline.txt
kernel8.img
initrd.img
bcm2710-rpi-3-b.dtb
{% endhighlight %}

####  Boot to test
Place the MicroSD on to the Raspberry Pi 3 and power it on.
You can now then verify at this point that our kernel boot as well and `will stop at some point` 
since we still do not have a filesystem.

If it did not boot or no display at all, we will use `U-Boot`.

Next is [Creating the filesystem]({{ site.baseurl }}{% post_url /ubuntu/_posts/2017-11-03-rpi3-setup-filesystem %}) for our Raspberry Pi 3 using Ubuntu Base.

##### Reference :
[https://wiki.ubuntu.com/ARM/RaspberryPi/RaspberryPi3](https://wiki.ubuntu.com/ARM/RaspberryPi/RaspberryPi3)\\
[https://wiki.ubuntu.com/Base](https://wiki.ubuntu.com/Base)\\
[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)\\
[https://kernelnomicon.org/?p=682](https://kernelnomicon.org/?p=682)</content><author><name></name></author><category term="Ubuntu" /><summary type="html">Cross-Build Prerequisites For building our own 64-bit kernel fom scratch using the Raspberry Pi Foundation repository, a couple of dependencies are needed. You may however use the mainline kernel though i haven’t tried to use it. 1 2 3 //make sure these are installed: bc git make device-tree-compiler gcc-aarch64-linux-gnu build-essential u-boot-tools ncurses-dev qemu-user-static pkg-config we also need: kernel RPi Repo file_download RPi firmware file_download bootcode.bin, start.elf, fixup.dat as this are the min. files to boot. The rest of star.* and fixup.* files for graphical desktop Compile the Kernel Use any Linux machine of your choice or Windows 10’s Bash to compile the kernel is all up to you. To get the kernel we need, we can either download it as a compressed file using the links above or we could use git to make it simpler. 1 git clone --depth 1 --branch rpi-4.14.y https://github.com/raspberrypi/linux.git rpi-4.14.70 1 2 3 mkdir bo_4.14 sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14 bcmrpi3_defconfig sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14 -j4 bcmrpi3_defconfig - arm64 config. -C source folder/. O=$HOME/output-folder - Output directory. -jX - build the kernel in a multithreaded way where: X = [Num of core x 2] Image file @ $HOME/bo_4.14/arch/arm64/boot/ bcm2710-rpi-3-b.dtb @ $HOME/bo_4.14/arch/arm64/boot/dts/broadcom/ Create config.txt and cmdline.txt For the config.txt and cmdline.txt, we have to create those files and add these lines. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //config.txt # Serial console output! enable_uart=1 # 64bit-mode arm_control=0x200 kernel=kernel8.img device_tree_address=0x100 device_tree_end=0x8000 # For i2c &amp;amp; spi dtparam=i2c_arm=on dtparam=spi=on 1 2 3 //cmd.txt dwc_otg.lpm_enable=0 console=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait Transfer the necessary files to the MicroSD Since we dont have a Ramdisk yet, we are using this 20160517-raspi3-arm64-firmware-kernel.tar.xz for now and we’ll create a new one on our own. To Do - i have to verify if this still works Rename the Image file we had earlier to kernel8.img. start.elf file knows kernel8.img file is a kernel to load. 1 2 3 4 5 6 7 8 9 10 //MicroSD card should now contain these files below bootcode.bin start.elf fixup.dat config.txt cmdline.txt kernel8.img initrd.img bcm2710-rpi-3-b.dtb Boot to test Place the MicroSD on to the Raspberry Pi 3 and power it on. You can now then verify at this point that our kernel boot as well and will stop at some point since we still do not have a filesystem. If it did not boot or no display at all, we will use U-Boot. Next is Creating the filesystem for our Raspberry Pi 3 using Ubuntu Base. Reference : https://wiki.ubuntu.com/ARM/RaspberryPi/RaspberryPi3 https://wiki.ubuntu.com/Base https://www.raspberrypi.org/documentation/linux/kernel/building.md https://kernelnomicon.org/?p=682</summary></entry><entry><title type="html">Raspberry Pi 3 with 64-bit U-Boot</title><link href="http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-uboot.html" rel="alternate" type="text/html" title="Raspberry Pi 3 with 64-bit U-Boot" /><published>2017-11-03T00:00:00+08:00</published><updated>2017-11-03T00:00:00+08:00</updated><id>http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-uboot</id><content type="html" xml:base="http://0.0.0.0:5000/ubuntu/rpi3-setup-64bit-uboot.html">This time let's try to use `U-Boot` to load the Linux kernel and boot our Raspberry Pi 3.
&lt;br /&gt;We need :
&lt;a href=&quot;ftp://ftp.denx.de/pub/u-boot/u-boot-2017.11.tar.bz2&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;
    U-Boot v.2017.11
    &lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;
&lt;/a&gt;


####  Get The SourceCode
Get the source code by cloning the U-Boot git repository :

{% highlight terminal linenos %}
git clone --depth 1 --branch v2017.11 git://git.denx.de/u-boot.git v2017.11
{% endhighlight %}

 or download the tar file :
{% highlight terminal linenos %}
wget ftp://ftp.denx.de/pub/u-boot/u-boot-2017.11.tar.bz2
{% endhighlight %}

####  Compile U-Boot
{% include callouts/callout.html content=&quot;`rpi_3_defconfig` - arm64 config RPi 3. `-C` source folder `v2017.11`&quot; type=&quot;note&quot;%}

{% highlight terminal linenos %}
sudo make -C v2017.11/ CROSS_COMPILE=aarch64-linux-gnu- rpi_3_defconfig
sudo make -C v2017.11/ CROSS_COMPILE=aarch64-linux-gnu-

    # For v2017.05 use below
sudo make -C v2017.05/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- rpi_3_defconfig
sudo make -C v2017.05/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
{% endhighlight %}

After it has been built. Locate `u-boot.bin` in your output_path as this is the file we need.

&lt;div class=&quot;mdc-tab-bar&quot; role=&quot;tablist&quot;&gt;
  &lt;div class=&quot;mdc-tab-scroller&quot;&gt;
    &lt;div class=&quot;mdc-tab-scroller__scroll-area mdc-tab-scroller__scroll-area--scroll&quot; style=&quot;margin-bottom: 0px;&quot;&gt;
      &lt;div class=&quot;mdc-tab-scroller__scroll-content&quot;&gt;
        &lt;button class=&quot;tab-item mdc-tab mdc-tab--active&quot; role=&quot;tab&quot; aria-selected=&quot;true&quot; tabindex=&quot;0&quot; onclick=&quot;openGPIO('default')&quot;&gt;
          &lt;span class=&quot;mdc-tab__content&quot;&gt;
            &lt;span class=&quot;mdc-tab__text-label&quot;&gt;Default&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab-indicator mdc-tab-indicator--active&quot;&gt;
            &lt;span class=&quot;mdc-tab-indicator__content mdc-tab-indicator__content--underline&quot;&gt;&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab__ripple mdc-ripple-upgraded&quot;&gt;&lt;/span&gt;
        &lt;/button&gt;
        &lt;button class=&quot;tab-item mdc-tab&quot; role=&quot;tab&quot; aria-selected=&quot;false&quot; tabindex=&quot;-1&quot; onclick=&quot;openGPIO('netboot')&quot;&gt;
          &lt;span class=&quot;mdc-tab__content&quot;&gt;
            &lt;span class=&quot;mdc-tab__text-label&quot;&gt;NetBoot&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab-indicator&quot;&gt;
            &lt;span class=&quot;mdc-tab-indicator__content mdc-tab-indicator__content--underline&quot;&gt;&lt;/span&gt;
          &lt;/span&gt;
          &lt;span class=&quot;mdc-tab__ripple mdc-ripple-upgraded&quot;&gt;&lt;/span&gt;
        &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;default&quot;&gt;
&lt;br /&gt;
&lt;h4&gt; Create the Bootscript &lt;/h4&gt;
Create a `rpi3-bootscript.txt` file and copy paste the code below :

{% highlight terminal linenos %}
// rpi3-bootscript.txt

setenv kernel_addr_r 0x01000000
setenv ramdisk_addr_r 0x02100000
fatload mmc 0:1 ${kernel_addr_r} boot/Image
fatload mmc 0:1 ${ramdisk_addr_r} boot/initrd.img
setenv initrdsize $filesize
booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r}
{% endhighlight %}

{% include callouts/callout.html content=&quot;`boot/Image` - The Linux kernel we compile from [Raspberry Pi 3 64-bit kernel](rpi3-setup-64bit-kernel) and place under a folder `boot`. \\
`boot/initrd.img` - Ramdisk image we created from [Using Ubuntu-base arm64 rootfs for Raspberry Pi 3](rpi3-setup-filesystem). \\
If you dont have a Ramdisk yet, replace `${ramdisk_addr_r}:${initrdsize}` with `-`. \\
`mkimage -T script -n 'Bootscript' -C none -d ~/&lt;input_file&gt; ~/&lt;output_file&gt;.scr` - Syntax for creating the bootscript&quot; type=&quot;note&quot;%}


Now to create a bootscript from the text file above :

{% highlight terminal linenos %}
$   sudo mkimage -A arm64 -O linux -T script -d ~/rpi3-bootscript.txt ~/boot.scr
{% endhighlight %}

Copy `boot.scr` to your MicroSD card inside `/boot` folder.
{% include callouts/callout.html type=&quot;note&quot; content=&quot;`u-boot.bin` - Can be renamed to `any-name` and modify it's entry in config.txt `kernel=boot/u-boot.bin-to-any-name`.&quot; %}

{% highlight terminal linenos %}
// config.txt

# Serial console output!
enable_uart=1

# 64bit-mode
arm_control=0x200

# Use U-Boot
kernel=boot/u-boot.bin

device_tree_address=0x100
device_tree_end=0x8000

dtparam=i2c_arm=on
dtparam=spi=on
{% endhighlight %}


Then verify your MicroSD directory structure like below :

{% highlight terminal linenos %}
/boot/Image
/boot/boot.scr
/boot/u-boot.bin
/boot/initrd.img
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
{% endhighlight %}

Boot it up to confirm that its working.

&lt;/div&gt;

&lt;!-- NetBoot --&gt;
&lt;div id=&quot;netboot&quot;&gt;
  For revision... TO-Do
&lt;/div&gt;

&lt;br /&gt;

&lt;h5&gt;  Reference : &lt;/h5&gt;
[http://www.denx.de/wiki/U-Boot/WebHome](http://www.denx.de/wiki/U-Boot/WebHome)


&lt;!-- for tabs --&gt;
&lt;script&gt;
  var demoItems = document.querySelectorAll('.tab-item');
  var tabItems = document.getElementsByClassName('.tab-item');
  
  [].forEach.call(demoItems, function (demoItem) {
    var activeIndicator = demoItem.querySelector('.mdc-tab-indicator');
  
    demoItem.addEventListener('click', function() {
      console.log(&quot;Clicked Test &quot; );
      [].forEach.call(demoItems, function (demoItem) {
        var indicatorEl = demoItem.querySelector('.mdc-tab-indicator');
        indicatorEl.classList.remove('mdc-tab-indicator--active');
      });
      activeIndicator.classList.toggle('mdc-tab-indicator--active');

      [].forEach.call(demoItems, function (demoItem) {
        demoItem.classList.remove('mdc-tab--active');
      });
      demoItem.classList.toggle('mdc-tab--active');

      

    });

  });

document.getElementById(&quot;netboot&quot;).style.display = &quot;none&quot;;

  function openGPIO(AppName) {
    document.getElementById(&quot;default&quot;).style.display = &quot;none&quot;;
    document.getElementById(&quot;netboot&quot;).style.display = &quot;none&quot;;
    document.getElementById(AppName).style.display = &quot;block&quot;;
  }
&lt;/script&gt;</content><author><name></name></author><category term="Ubuntu" /><summary type="html">This time let’s try to use U-Boot to load the Linux kernel and boot our Raspberry Pi 3. We need : U-Boot v.2017.11 file_download Get The SourceCode Get the source code by cloning the U-Boot git repository : 1 git clone --depth 1 --branch v2017.11 git://git.denx.de/u-boot.git v2017.11 or download the tar file : 1 wget ftp://ftp.denx.de/pub/u-boot/u-boot-2017.11.tar.bz2 Compile U-Boot rpi_3_defconfig - arm64 config RPi 3. -C source folder v2017.11 1 2 3 4 5 6 sudo make -C v2017.11/ CROSS_COMPILE=aarch64-linux-gnu- rpi_3_defconfig sudo make -C v2017.11/ CROSS_COMPILE=aarch64-linux-gnu- # For v2017.05 use below sudo make -C v2017.05/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- rpi_3_defconfig sudo make -C v2017.05/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- After it has been built. Locate u-boot.bin in your output_path as this is the file we need. Default NetBoot Create the Bootscript Create a `rpi3-bootscript.txt` file and copy paste the code below : 1 2 3 4 5 6 7 8 // rpi3-bootscript.txt setenv kernel_addr_r 0x01000000 setenv ramdisk_addr_r 0x02100000 fatload mmc 0:1 ${kernel_addr_r} boot/Image fatload mmc 0:1 ${ramdisk_addr_r} boot/initrd.img setenv initrdsize $filesize booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r} boot/Image - The Linux kernel we compile from Raspberry Pi 3 64-bit kernel and place under a folder boot. boot/initrd.img - Ramdisk image we created from Using Ubuntu-base arm64 rootfs for Raspberry Pi 3. If you dont have a Ramdisk yet, replace ${ramdisk_addr_r}:${initrdsize} with -. mkimage -T script -n 'Bootscript' -C none -d ~/&amp;lt;input_file&amp;gt; ~/&amp;lt;output_file&amp;gt;.scr - Syntax for creating the bootscript Now to create a bootscript from the text file above : 1 $ sudo mkimage -A arm64 -O linux -T script -d ~/rpi3-bootscript.txt ~/boot.scr Copy `boot.scr` to your MicroSD card inside `/boot` folder. u-boot.bin - Can be renamed to any-name and modify it’s entry in config.txt kernel=boot/u-boot.bin-to-any-name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // config.txt # Serial console output! enable_uart=1 # 64bit-mode arm_control=0x200 # Use U-Boot kernel=boot/u-boot.bin device_tree_address=0x100 device_tree_end=0x8000 dtparam=i2c_arm=on dtparam=spi=on Then verify your MicroSD directory structure like below : 1 2 3 4 5 6 7 8 9 10 /boot/Image /boot/boot.scr /boot/u-boot.bin /boot/initrd.img bcm2710-rpi-3-b.dtb bootcode.bin start.elf fixup.dat config.txt cmdline.txt Boot it up to confirm that its working. For revision... TO-Do Reference : [http://www.denx.de/wiki/U-Boot/WebHome](http://www.denx.de/wiki/U-Boot/WebHome)</summary></entry><entry><title type="html">Using Ubuntu-base arm64 rootfs for Raspberry Pi 3</title><link href="http://0.0.0.0:5000/ubuntu/rpi3-setup-filesystem.html" rel="alternate" type="text/html" title="Using Ubuntu-base arm64 rootfs for Raspberry Pi 3" /><published>2017-11-03T00:00:00+08:00</published><updated>2017-11-03T00:00:00+08:00</updated><id>http://0.0.0.0:5000/ubuntu/rpi3-setup-filesystem</id><content type="html" xml:base="http://0.0.0.0:5000/ubuntu/rpi3-setup-filesystem.html">#### Extract the Rootfs
To create our bare filesystem, we need:

&lt;a href=&quot;http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.1/release/ubuntu-base-18.04.1-base-arm64.tar.gz&quot; class=&quot;mdc-button mdc-button--compact&quot;&gt;
        Ubuntu Base 18.04.1
        &lt;i class=&quot;material-icons mdc-button__icon&quot;&gt;file_download&lt;/i&gt;
&lt;/a&gt;

{% include callouts/callout.html content=&quot;`-C` - To extract the files in a different directory&quot; type=&quot;note&quot; %}

{% highlight terminal linenos %}
wget http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.1/release/ubuntu-base-18.04.1-base-arm64.tar.gz
mkdir rootfs
sudo tar xzvf ubuntu-base-18.04.1-base-arm64.tar.gz -C $HOME/rootfs
{% endhighlight %}

####  Modifying the Rootfs
Going back from when we compile the Raspberry Pi 3 kernel, We are goig to install the kernel module and firmware into the rootfs folder that we just created above.

{% highlight terminal linenos %}
sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14/ modules_install INSTALL_MOD_PATH=$HOME/rootfs/

# Starting kernel &gt; 4.14 use your debian based &quot;linux-firmware&quot; package:
# For kernel &lt; 4.13 include below commands for firmware:
sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14/ firmware_install INSTALL_FW_PATH=$HOME/rootfs/lib/firmware/
{% endhighlight %}

Verify that it was installed correctly. And remove `build` and `source` links.

{% highlight terminal linenos %}
ls $HOME/rootfs/lib/modules/4.11~

modules.builtin     modules.devname        modules.symbols.bin  build
kernel              modules.builtin.bin    modules.order        source
modules.alias       modules.dep            modules.softdep
modules.alias.bin   modules.dep.bin        modules.symbols

sudo find $HOME/rootfs/ -name build | xargs rm -rf
sudo find $HOME/rootfs/ -name source | xargs rm -rf
{% endhighlight %}

Well use `chroot` to further setup our filesystem.

{% highlight terminal linenos %}
sudo cp -av /usr/bin/qemu-aarch64-static $HOME/rootfs/usr/bin
{% endhighlight %}

Then we need to copy `resolv.conf` from our host machine for internet connection to `$HOME/rootfs/etc/`:

{% highlight terminal linenos %}
# If your host is Ubuntu 17.10
sudo cp -av /run/systemd/resolve/stub-resolv.conf $HOME/rootfs/etc/resolv.conf

# For Ubuntu 16.04.3 below
sudo cp -av /run/resolvconf/resolv.conf $HOME/rootfs/etc/resolv.conf
{% endhighlight %}

Enter chroot environment:

{% highlight terminal linenos %}
sudo chroot $HOME/rootfs/
{% endhighlight %}

Now that you're in the chroot environment, we can now add an admin user with sudo permission.

{% highlight terminal linenos %}
useradd -G sudo -m -s /bin/bash pi3
echo pi3:pi3 | chpasswd
{% endhighlight %}

&gt;   The format input line of chpasswd is: user_name:password.

&lt;br /&gt;
Change root password with these command:

{% highlight terminal linenos %}
passwd root
{% endhighlight %}

You can setup your `hostname` here for your target device or in the kernel configuration making sure that the hostname is empty.

{% highlight terminal linenos %}
echo U-Base_min &gt; /etc/hostname
echo 127.0.0.1	localhost &gt; /etc/hosts
echo 127.0.1.1	U-Base_min &gt;&gt; /etc/hosts
{% endhighlight %}

Fetch the latest package lists from server then upgrade.

{% highlight terminal linenos %}
apt-get update
apt-get upgrade
{% endhighlight %}

Then install these first:

{% highlight terminal linenos %}
apt-get install dialog perl
{% endhighlight %}

We need those installed first to correct some error messages about locale: If `locale-gen` command is missing, `apt-get install locales` first.

{% highlight terminal linenos %}
locale-gen &quot;en_US.UTF-8&quot;
        Generating locales...
            en_US.UTF-8... done
        Generation complete.
{% endhighlight %}

Install minimal packages:

{% highlight terminal linenos %}
apt-get install sudo ifupdown net-tools ethtool udev wireless-tools iputils-ping resolvconf wget apt-utils wpasupplicant initramfs-tools
{% endhighlight %}

{% include callouts/callout.html type=&quot;note&quot; content=&quot;To-Do: gonna use Netplan for future network management&quot; %}

Create our Ramdisk.

{% highlight terminal linenos %}
mkinitramfs -o /boot/initrd.img /lib/modules/4.11~
{% endhighlight %}

When everything you want are done, exit chroot:

{% highlight terminal linenos %}
exit
{% endhighlight %}

We need to add `/etc/fstab` file entry below coz' if not...it will run on read-only mode. Below are `Tab` not `spacebar`

{% highlight terminal linenos %}
echo &quot;/dev/mmcblk0p2	/	ext4	defaults,noatime	0	1&quot; &gt;&gt; $HOME/rootfs/etc/fstab
{% endhighlight %}

####  Removing unwanted files
To reduce the rootfs/ size we can remove some unwanted files.
Create a file `/etc/dpkg/dpkg.cfg.d/01_nodoc` which specifies the desired filters. Example:

{% highlight terminal linenos %}
path-exclude /usr/share/doc/*
# we need to keep copyright files for legal reasons
path-include /usr/share/doc/*/copyright
path-exclude /usr/share/man/*
path-exclude /usr/share/groff/*
path-exclude /usr/share/info/*
# lintian stuff is small, but really unnecessary
path-exclude /usr/share/lintian/*
path-exclude /usr/share/linda/*
{% endhighlight %}

Then you can manually remove any documentation already installed:

{% highlight terminal linenos %}
sudo find rootfs/usr/share/doc -depth -type f ! -name copyright|xargs rm || true
sudo find rootfs/usr/share/doc -empty|xargs rmdir || true
sudo rm -rf rootfs/usr/share/man/* rootfs/usr/share/groff/* rootfs/usr/share/info/*
sudo rm -rf rootfs/usr/share/lintian/* rootfs/usr/share/linda/* rootfs/var/cache/man/*
{% endhighlight %}

Then copy the `$HOME/rootfs/*` content to the 2nd partition of your MicroSD card.

&lt;br /&gt;
####  Creating the Image file (*Optional)
We could make an image file with several partition on it. 
We will create a 700M empty img file:
{% include callouts/callout.html type=&quot;note&quot; content=&quot;Modify the desired image size according to your needs. I use `resize2fs` after i boot this up&quot; %}

{% highlight terminal linenosw %}
sudo dd if=/dev/zero of=myimage.img bs=700K count=1024
{% endhighlight %}

Then partition it using `fdisk` in my case:

{% highlight terminal linenos %}
sudo fdisk -l myimage.img
        Result:
        | Device     w| Boot | Start 	| End	  | Sectors |
        |:-----------|:-----|:----------|:--------|:--------|
        | myimage1   |      | 2048  	| 264191  | 1024000 | Fat32
        | myimage2   |      | 264192 	| 1433599 | 3168256 | Linux
{% endhighlight %}

{% include callouts/callout.html content=&quot;For 32Bit don't use `Fat32(LTB)`&quot; type=&quot;note&quot; %}

Display the name of the assigned loop device:

{% highlight terminal linenos %}
sudo losetup --find --show myimage.img
	
	    /dev/loop0
{% endhighlight %}

Then we can use `fdisk` to identify our image file partitions assinged loop

{% highlight terminal linenos %}
sudo fdisk -l /dev/loop0

        Device:
            /dev/loop0p1
            /dev/loop0p2
{% endhighlight %}

Then, to assign a loopback device: and format it.

{% highlight terminal linenos %}
sudo losetup -o $((512*2048)) --sizelimit $((512*264191)) /dev/loop1 myimage.img 
sudo losetup -o $((512*264192)) --sizelimit $((512*1433599)) /dev/loop2 myimage.img
sudo mkfs.vfat -F 32 -n 'SYS-BOOT' /dev/loop1
sudo mkfs.ext4 /dev/loop2
{% endhighlight %}

{% include callouts/callout.html content=&quot;mkfs.vfat -n `partition name` /dev/loop1.&quot; type=&quot;note&quot; %}

Mount and Copy those necessary files that we need to their respected partition.
Install `dosfstools` if cannot mount vfat

{% highlight terminal linenos %}
sudo mount /dev/loop1 /mnt/boot
sudo mount /dev/loop2 /mnt/rootfs

    # Then umount and detach:
sudo umount /dev/loop1
sudo umount /dev/loop2
sudo losetup --detach /dev/loop1
sudo losetup --detach /dev/loop2
{% endhighlight %}

You can now burn that myimage.img to yor MicoSD card.
Now boot it up and you should now be able to login.

&lt;br /&gt;

##### Reference :
[http://docs.khadas.com/social/BuildUbuntuRootfsViaUbuntuBase/](http://docs.khadas.com/social/BuildUbuntuRootfsViaUbuntuBase/)\\
[https://gnu-linux.org/building-ubuntu-rootfs-for-arm.html](https://gnu-linux.org/building-ubuntu-rootfs-for-arm.html)\\
[http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html](http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html)</content><author><name></name></author><category term="Ubuntu" /><summary type="html">Extract the Rootfs To create our bare filesystem, we need: Ubuntu Base 18.04.1 file_download -C - To extract the files in a different directory 1 2 3 wget http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.1/release/ubuntu-base-18.04.1-base-arm64.tar.gz mkdir rootfs sudo tar xzvf ubuntu-base-18.04.1-base-arm64.tar.gz -C $HOME/rootfs Modifying the Rootfs Going back from when we compile the Raspberry Pi 3 kernel, We are goig to install the kernel module and firmware into the rootfs folder that we just created above. 1 2 3 4 5 sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14/ modules_install INSTALL_MOD_PATH=$HOME/rootfs/ # Starting kernel &amp;gt; 4.14 use your debian based &quot;linux-firmware&quot; package: # For kernel &amp;lt; 4.13 include below commands for firmware: sudo make -C rpi-4.14.70/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=$HOME/bo_4.14/ firmware_install INSTALL_FW_PATH=$HOME/rootfs/lib/firmware/ Verify that it was installed correctly. And remove build and source links. 1 2 3 4 5 6 7 8 9 ls $HOME/rootfs/lib/modules/4.11~ modules.builtin modules.devname modules.symbols.bin build kernel modules.builtin.bin modules.order source modules.alias modules.dep modules.softdep modules.alias.bin modules.dep.bin modules.symbols sudo find $HOME/rootfs/ -name build | xargs rm -rf sudo find $HOME/rootfs/ -name source | xargs rm -rf Well use chroot to further setup our filesystem. 1 sudo cp -av /usr/bin/qemu-aarch64-static $HOME/rootfs/usr/bin Then we need to copy resolv.conf from our host machine for internet connection to $HOME/rootfs/etc/: 1 2 3 4 5 # If your host is Ubuntu 17.10 sudo cp -av /run/systemd/resolve/stub-resolv.conf $HOME/rootfs/etc/resolv.conf # For Ubuntu 16.04.3 below sudo cp -av /run/resolvconf/resolv.conf $HOME/rootfs/etc/resolv.conf Enter chroot environment: 1 sudo chroot $HOME/rootfs/ Now that you’re in the chroot environment, we can now add an admin user with sudo permission. 1 2 useradd -G sudo -m -s /bin/bash pi3 echo pi3:pi3 | chpasswd The format input line of chpasswd is: user_name:password. Change root password with these command: 1 passwd root You can setup your hostname here for your target device or in the kernel configuration making sure that the hostname is empty. 1 2 3 echo U-Base_min &amp;gt; /etc/hostname echo 127.0.0.1 localhost &amp;gt; /etc/hosts echo 127.0.1.1 U-Base_min &amp;gt;&amp;gt; /etc/hosts Fetch the latest package lists from server then upgrade. 1 2 apt-get update apt-get upgrade Then install these first: 1 apt-get install dialog perl We need those installed first to correct some error messages about locale: If locale-gen command is missing, apt-get install locales first. 1 2 3 4 locale-gen &quot;en_US.UTF-8&quot; Generating locales... en_US.UTF-8... done Generation complete. Install minimal packages: 1 apt-get install sudo ifupdown net-tools ethtool udev wireless-tools iputils-ping resolvconf wget apt-utils wpasupplicant initramfs-tools To-Do: gonna use Netplan for future network management Create our Ramdisk. 1 mkinitramfs -o /boot/initrd.img /lib/modules/4.11~ When everything you want are done, exit chroot: 1 exit We need to add /etc/fstab file entry below coz’ if not…it will run on read-only mode. Below are Tab not spacebar 1 echo &quot;/dev/mmcblk0p2 / ext4 defaults,noatime 0 1&quot; &amp;gt;&amp;gt; $HOME/rootfs/etc/fstab Removing unwanted files To reduce the rootfs/ size we can remove some unwanted files. Create a file /etc/dpkg/dpkg.cfg.d/01_nodoc which specifies the desired filters. Example: 1 2 3 4 5 6 7 8 9 path-exclude /usr/share/doc/* # we need to keep copyright files for legal reasons path-include /usr/share/doc/*/copyright path-exclude /usr/share/man/* path-exclude /usr/share/groff/* path-exclude /usr/share/info/* # lintian stuff is small, but really unnecessary path-exclude /usr/share/lintian/* path-exclude /usr/share/linda/* Then you can manually remove any documentation already installed: 1 2 3 4 sudo find rootfs/usr/share/doc -depth -type f ! -name copyright|xargs rm || true sudo find rootfs/usr/share/doc -empty|xargs rmdir || true sudo rm -rf rootfs/usr/share/man/* rootfs/usr/share/groff/* rootfs/usr/share/info/* sudo rm -rf rootfs/usr/share/lintian/* rootfs/usr/share/linda/* rootfs/var/cache/man/* Then copy the $HOME/rootfs/* content to the 2nd partition of your MicroSD card. Creating the Image file (*Optional) We could make an image file with several partition on it. We will create a 700M empty img file: Modify the desired image size according to your needs. I use resize2fs after i boot this up sudo dd if=/dev/zero of=myimage.img bs=700K count=1024 Then partition it using fdisk in my case: 1 2 3 4 5 6 sudo fdisk -l myimage.img Result: | Device w| Boot | Start | End | Sectors | |:-----------|:-----|:----------|:--------|:--------| | myimage1 | | 2048 | 264191 | 1024000 | Fat32 | myimage2 | | 264192 | 1433599 | 3168256 | Linux For 32Bit don’t use Fat32(LTB) Display the name of the assigned loop device: 1 2 3 sudo losetup --find --show myimage.img /dev/loop0 Then we can use fdisk to identify our image file partitions assinged loop 1 2 3 4 5 sudo fdisk -l /dev/loop0 Device: /dev/loop0p1 /dev/loop0p2 Then, to assign a loopback device: and format it. 1 2 3 4 sudo losetup -o $((512*2048)) --sizelimit $((512*264191)) /dev/loop1 myimage.img sudo losetup -o $((512*264192)) --sizelimit $((512*1433599)) /dev/loop2 myimage.img sudo mkfs.vfat -F 32 -n 'SYS-BOOT' /dev/loop1 sudo mkfs.ext4 /dev/loop2 mkfs.vfat -n partition name /dev/loop1. Mount and Copy those necessary files that we need to their respected partition. Install dosfstools if cannot mount vfat 1 2 3 4 5 6 7 8 sudo mount /dev/loop1 /mnt/boot sudo mount /dev/loop2 /mnt/rootfs # Then umount and detach: sudo umount /dev/loop1 sudo umount /dev/loop2 sudo losetup --detach /dev/loop1 sudo losetup --detach /dev/loop2 You can now burn that myimage.img to yor MicoSD card. Now boot it up and you should now be able to login. Reference : http://docs.khadas.com/social/BuildUbuntuRootfsViaUbuntuBase/ https://gnu-linux.org/building-ubuntu-rootfs-for-arm.html http://manpages.ubuntu.com/manpages/xenial/man8/losetup.8.html</summary></entry><entry><title type="html">Raspberry Pi 3 Alpine Linux arm64</title><link href="http://0.0.0.0:5000/alpine/alpine-linux.html" rel="alternate" type="text/html" title="Raspberry Pi 3 Alpine Linux arm64" /><published>2017-06-15T00:00:00+08:00</published><updated>2017-06-15T00:00:00+08:00</updated><id>http://0.0.0.0:5000/alpine/alpine-linux</id><content type="html" xml:base="http://0.0.0.0:5000/alpine/alpine-linux.html">###### *** 18-09-20: `Will update soon...`
###### *** 17-07-06: To fix brcmfmac loading error: directly place `brcm` folder inside our custom `initramfs-rpi3` file.
###### *** 17-07-06: `b43` is optional...

As i was been busy studying and learning about Docker and how nice it is to use Alpine linux as the docker image for .NetCore because of it being small in size... unlike using ubuntu as a docker image file...This time... i decided to try Alpine linux on Raspberry Pi 3.

&lt;a href=&quot;http://dl-cdn.alpinelinux.org/alpine/v3.7/releases/aarch64/alpine-uboot-3.7.0-aarch64.tar.gz&quot; class=&quot;card btn blue&quot;&gt;Alpine 3.7 Generic arm64&lt;i class=&quot;material-icons right&quot;&gt;file_download&lt;/i&gt;&lt;/a&gt;

{% include callouts/callout.html type=&quot;note&quot; content=&quot;Make sure `SquashFS is enabled`&quot; %}

{% highlight terminal linenos %}
// Kernel config

File systems
    |-  Miscellaneous filesystems
        |-  [*] SquashFS 4.0
{% endhighlight %}

{% include callouts/callout.html type=&quot;note&quot; content=&quot;For our custom `kernel and U-boot`... just follow [Raspberry Pi 3 64-bit kernel](/ubuntu/rpi3-setup-64bit-kernel).&quot; %}

The files that we need from alpine to modify is `initramfs-vanilla`, and a copy of `apk` folder (`alpine.apkovl.tar.gz` is optional). so go ahead and extract them.

`initramfs-vanilla` is a compressed cpio archive. To extract it we do this:
{% highlight terminal linenos %}
mkdir $HOME/temp
cd $HOME/temp
sudo gunzip -c /boot/initramfs-vanilla | cpio -i
{% endhighlight %}

Then we need to install our latest modules into it...assuming you already compiled a kernel following this [Raspberry Pi 3 64-bit kernel](/ubuntu/rpi3-setup-64bit-kernel).

{% highlight terminal linenos %}
sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make -C rpi-4.14/ modules_install INSTALL_MOD_PATH=$HOME/temp/
        
        # When it is done go back to /temp/ folder where we extract the initramfs and into the modules folder.

cd $HOME/temp/lib/modules/
        
        # And remove the previous version and the build, source folder symlink in $HOME/temp/lib/modules/4.1x~/ folder

sudo rm -rf 4.9~/
{% endhighlight %}

Now we have our custom initramfs and then recreate the compressed cpio archive again.
Inside the folder run:
{% highlight terminal linenos %}
sudo find . | cpio -H newc -o | gzip -9 &gt; [file destination]/initramfs-rpi3-cpio
cd ..
sudo mkimage -A arm64 -O linux -T ramdisk -d initramfs-rpi3-cpio initramfs-rpi3 // For U-boot
{% endhighlight %}

`modloop-vanilla` is a squashfs file. We can make from scratch or unsquash it using this command:
{% highlight terminal linenos %}
sudo unsquashfs -f -d [file destination] [file location]/file.squashfs
{% endhighlight %}

To create our own `modloop` file let start by making a folder
{% highlight terminal linenos %}
sudo mkdir modules 
        # Then inside this module, let's install again our rpi-4.11y modules from above
{% endhighlight %}

After you've installed `our modules from above` on the modules folder that we've just created.. you'll have a folder structure like so:
{% highlight terminal linenos %}
/modules
        |- /lib
                |- /firmware
                        # firmware_install INSTALL_FW_PATH=[in this location or just use from the moodlop-vanilla]
                        # Use firmware_install if using kernel &lt;- 4.13

                |- /modules
                        # again remove build and source symlink folder here
{% endhighlight %}

Rearrange above modules folder to: 
{% highlight terminal linenos %}
/modules/modules/firmware
/modules/modules/4.1x~
{% endhighlight %}

Squash it using this command:
{% highlight terminal linenos %}
sudo mksquashfs [folder to be squash] [filename] -comp [compression method: I use 'xz' -Xdict-size 100%
{% endhighlight %}

And now we have our own `initramfs-rpi3` and `modloop-rpi3`. Our µsd card should now look like this:
{% highlight terminal linenos %}
/apk
/boot/Image
/boot/u-boot.bin
/boot/boot.scr
/boot/initramfs-rpi3
/boot/modloop-rpi3
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux
{% endhighlight %}

We'll modify the `cmdline.txt` and `boot.scr` for alpine linux.
 alerts/code.html type=&quot;cmdline.txt:&quot; code=&quot;&lt;br/&gt;
{% highlight terminal linenos %}
modules=loop,squashfs,sd-mod,usb-storage quiet net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 fsck.repair=yes rootwait

# the quiet command can be remove: it just hide the message buffer of kernel. `ttyS0` can be replace by `ttyAMA0`
{% endhighlight %}

{% highlight terminal linenos %}
fdt addr 0x100
fdt get value bootargs /chosen bootargs
setenv kernel_addr_r 0x01000000
setenv ramdisk_addr_r 0x02100000
fatload mmc 0:1 ${kernel_addr_r} boot/Image
fatload mmc 0:1 ${ramdisk_addr_r} boot/initramfs-rpi3
setenv initrdsize $filesize
fatload mmc 0:1 ${fdt_addr_r} bcm2710-rpi-3-b.dtb
booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r}
{% endhighlight %}

Go ahead noew and try to boot it up. You should have an output like this:

![](/assets/images/alpine/alpine-linux-arm64-rpi3.jpg){:class=&quot;responsive-img&quot;}

As you can see... there's a hwclock error since our raspberry pi 3 don't have any. So after you run `setup-alpine` and use `lbu commit ` to save changes...run this:
{% highlight terminal linenos %}
rc-update add swclock boot    // enable the software clock
rc-update del hwclock boot    // disable the hardware clock
{% endhighlight %}
In my case i use `Busybox NTP` as it might be the most lightweight solution. Save the changes and reboot.
{% highlight terminal linenos %}
lbu commit
apk add wireless-tools wpa_supplicant  // will be installed even when not connected to the net
reboot
{% endhighlight %}
&lt;br /&gt;

#### Wifi: (*Optional)

I didn't include the `brcm` above because i encouter a `brcmf_sdio_htclk` error but can be resolve by reloading the module: `brcmfmac`
The good thing about alpine linux is if you make a `firmware folder` on the root directory of our µsd card, it'll be recognized by alpine and load it once alpine boot up. Don't worry if the rest of the folder inside the OS fimrware folder is gone(it's  just hidden in plain site). So i place my brcm folder there for now. 

According to alpine linux... [Connecting to a wireless access point](https://wiki.alpinelinux.org/wiki/Connecting_to_a_wireless_access_point) Broadcom Wi-Fi Chipset Users: we need `b43-firmware` so go ahead and follow that or we can compile it somewhere else like what i did.

On ubuntu 16.04 i install `b43-fwcutter` then get [b43-firmware](http://mirror2.openwrt.org/sources/broadcom-wl-4.150.10.5.tar.bz2) and follow the instruction [here](http://linuxwireless.org/en/users/Drivers/b43/)

{% highlight terminal linenos %}
tar -xjf broadcom-wl-4.150.10.5.tar.bz2       // make sure bzip is installed
b43-fwcutter -w [$FIRMWARE_INSTALL_DIR/b43] broadcom-wl-4.150.10.5/driver/wl_apsta_mimo.o
{% endhighlight %}

Then copy that `b43` folder to firmware folder on the root of our µsd card.
{% highlight terminal linenos %}
/apk
/boot/Image
/boot/kernel8.img
/boot/boot.scr
/boot/initramfs-rpi3
/boot/modloop-rpi3
/firmware/b43
/firmware/brcm
bcm2710-rpi-3-b.dtb
bootcode.bin
start.elf 
fixup.dat 
config.txt
cmdline.txt
alpine.apkovl.tar.gz # optional will be created once we setup our alpine linux
{% endhighlight %}

Load the `b43` kernel and enable it at boot up:
{% highlight terminal linenos %}
modprobe b43
echo b43 &gt;&gt; /etc/modules
lbu commit    // To save changes
{% endhighlight %}

If you run `dmesg` command and display a brcmfmac error just reload `brcmfmac module`:
{% highlight terminal linenos %}
modprobe -r brcmfmac  // For now
modprobe brcmfmac
{% endhighlight %}

&lt;br /&gt;

#####    Reference :

[http://backreference.org/2010/07/04/modifying-initrdinitramfs-files/](http://backreference.org/2010/07/04/modifying-initrdinitramfs-files/)\\
[https://askubuntu.com/questions/437880/extract-a-squashfs-to-an-existing-directory](https://askubuntu.com/questions/437880/extract-a-squashfs-to-an-existing-directory)\\
[https://wiki.alpinelinux.org/wiki/DIY_Fully_working_Alpine_Linux_for_Allwinner_and_Other_ARM_SOCs](https://wiki.alpinelinux.org/wiki/DIY_Fully_working_Alpine_Linux_for_Allwinner_and_Other_ARM_SOCs)\\
[https://wiki.alpinelinux.org/wiki/Raspberry_Pi](https://wiki.alpinelinux.org/wiki/Raspberry_Pi)</content><author><name></name></author><category term="Alpine" /><summary type="html">*** 18-09-20: Will update soon... *** 17-07-06: To fix brcmfmac loading error: directly place brcm folder inside our custom initramfs-rpi3 file. *** 17-07-06: b43 is optional… As i was been busy studying and learning about Docker and how nice it is to use Alpine linux as the docker image for .NetCore because of it being small in size… unlike using ubuntu as a docker image file…This time… i decided to try Alpine linux on Raspberry Pi 3. Alpine 3.7 Generic arm64file_download Make sure SquashFS is enabled 1 2 3 4 5 // Kernel config File systems |- Miscellaneous filesystems |- [*] SquashFS 4.0 For our custom kernel and U-boot… just follow Raspberry Pi 3 64-bit kernel. The files that we need from alpine to modify is initramfs-vanilla, and a copy of apk folder (alpine.apkovl.tar.gz is optional). so go ahead and extract them. initramfs-vanilla is a compressed cpio archive. To extract it we do this: 1 2 3 mkdir $HOME/temp cd $HOME/temp sudo gunzip -c /boot/initramfs-vanilla | cpio -i Then we need to install our latest modules into it…assuming you already compiled a kernel following this Raspberry Pi 3 64-bit kernel. 1 2 3 4 5 6 7 8 9 sudo ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make -C rpi-4.14/ modules_install INSTALL_MOD_PATH=$HOME/temp/ # When it is done go back to /temp/ folder where we extract the initramfs and into the modules folder. cd $HOME/temp/lib/modules/ # And remove the previous version and the build, source folder symlink in $HOME/temp/lib/modules/4.1x~/ folder sudo rm -rf 4.9~/ Now we have our custom initramfs and then recreate the compressed cpio archive again. Inside the folder run: 1 2 3 sudo find . | cpio -H newc -o | gzip -9 &amp;gt; [file destination]/initramfs-rpi3-cpio cd .. sudo mkimage -A arm64 -O linux -T ramdisk -d initramfs-rpi3-cpio initramfs-rpi3 // For U-boot modloop-vanilla is a squashfs file. We can make from scratch or unsquash it using this command: 1 sudo unsquashfs -f -d [file destination] [file location]/file.squashfs To create our own modloop file let start by making a folder 1 2 sudo mkdir modules # Then inside this module, let's install again our rpi-4.11y modules from above After you’ve installed our modules from above on the modules folder that we’ve just created.. you’ll have a folder structure like so: 1 2 3 4 5 6 7 8 /modules |- /lib |- /firmware # firmware_install INSTALL_FW_PATH=[in this location or just use from the moodlop-vanilla] # Use firmware_install if using kernel &amp;lt;- 4.13 |- /modules # again remove build and source symlink folder here Rearrange above modules folder to: 1 2 /modules/modules/firmware /modules/modules/4.1x~ Squash it using this command: 1 sudo mksquashfs [folder to be squash] [filename] -comp [compression method: I use 'xz' -Xdict-size 100% And now we have our own initramfs-rpi3 and modloop-rpi3. Our µsd card should now look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 /apk /boot/Image /boot/u-boot.bin /boot/boot.scr /boot/initramfs-rpi3 /boot/modloop-rpi3 bcm2710-rpi-3-b.dtb bootcode.bin start.elf fixup.dat config.txt cmdline.txt alpine.apkovl.tar.gz // optional will be created once we setup our alpine linux We’ll modify the cmdline.txt and boot.scr for alpine linux. alerts/code.html type=”cmdline.txt:” code=” 1 2 3 modules=loop,squashfs,sd-mod,usb-storage quiet net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 fsck.repair=yes rootwait # the quiet command can be remove: it just hide the message buffer of kernel. `ttyS0` can be replace by `ttyAMA0` 1 2 3 4 5 6 7 8 9 fdt addr 0x100 fdt get value bootargs /chosen bootargs setenv kernel_addr_r 0x01000000 setenv ramdisk_addr_r 0x02100000 fatload mmc 0:1 ${kernel_addr_r} boot/Image fatload mmc 0:1 ${ramdisk_addr_r} boot/initramfs-rpi3 setenv initrdsize $filesize fatload mmc 0:1 ${fdt_addr_r} bcm2710-rpi-3-b.dtb booti ${kernel_addr_r} ${ramdisk_addr_r}:${initrdsize} ${fdt_addr_r} Go ahead noew and try to boot it up. You should have an output like this: As you can see… there’s a hwclock error since our raspberry pi 3 don’t have any. So after you run setup-alpine and use lbu commit to save changes…run this: 1 2 rc-update add swclock boot // enable the software clock rc-update del hwclock boot // disable the hardware clock In my case i use Busybox NTP as it might be the most lightweight solution. Save the changes and reboot. 1 2 3 lbu commit apk add wireless-tools wpa_supplicant // will be installed even when not connected to the net reboot Wifi: (*Optional) I didn’t include the brcm above because i encouter a brcmf_sdio_htclk error but can be resolve by reloading the module: brcmfmac The good thing about alpine linux is if you make a firmware folder on the root directory of our µsd card, it’ll be recognized by alpine and load it once alpine boot up. Don’t worry if the rest of the folder inside the OS fimrware folder is gone(it’s just hidden in plain site). So i place my brcm folder there for now. According to alpine linux… Connecting to a wireless access point Broadcom Wi-Fi Chipset Users: we need b43-firmware so go ahead and follow that or we can compile it somewhere else like what i did. On ubuntu 16.04 i install b43-fwcutter then get b43-firmware and follow the instruction here 1 2 tar -xjf broadcom-wl-4.150.10.5.tar.bz2 // make sure bzip is installed b43-fwcutter -w [$FIRMWARE_INSTALL_DIR/b43] broadcom-wl-4.150.10.5/driver/wl_apsta_mimo.o Then copy that b43 folder to firmware folder on the root of our µsd card. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /apk /boot/Image /boot/kernel8.img /boot/boot.scr /boot/initramfs-rpi3 /boot/modloop-rpi3 /firmware/b43 /firmware/brcm bcm2710-rpi-3-b.dtb bootcode.bin start.elf fixup.dat config.txt cmdline.txt alpine.apkovl.tar.gz # optional will be created once we setup our alpine linux Load the b43 kernel and enable it at boot up: 1 2 3 modprobe b43 echo b43 &amp;gt;&amp;gt; /etc/modules lbu commit // To save changes If you run dmesg command and display a brcmfmac error just reload brcmfmac module: 1 2 modprobe -r brcmfmac // For now modprobe brcmfmac Reference : http://backreference.org/2010/07/04/modifying-initrdinitramfs-files/ https://askubuntu.com/questions/437880/extract-a-squashfs-to-an-existing-directory https://wiki.alpinelinux.org/wiki/DIY_Fully_working_Alpine_Linux_for_Allwinner_and_Other_ARM_SOCs https://wiki.alpinelinux.org/wiki/Raspberry_Pi</summary></entry></feed>